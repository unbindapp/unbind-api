// Code generated by mockery v2.53.0. DO NOT EDIT.

package mocks_repository_deployment

import (
	context "context"

	ent "github.com/unbindapp/unbind-api/ent"

	mock "github.com/stretchr/testify/mock"

	repository "github.com/unbindapp/unbind-api/internal/repositories"

	schema "github.com/unbindapp/unbind-api/ent/schema"

	time "time"

	uuid "github.com/google/uuid"

	v1 "github.com/unbindapp/unbind-operator/api/v1"
)

// DeploymentRepositoryMock is an autogenerated mock type for the DeploymentRepositoryInterface type
type DeploymentRepositoryMock struct {
	mock.Mock
}

type DeploymentRepositoryMock_Expecter struct {
	mock *mock.Mock
}

func (_m *DeploymentRepositoryMock) EXPECT() *DeploymentRepositoryMock_Expecter {
	return &DeploymentRepositoryMock_Expecter{mock: &_m.Mock}
}

// AssignKubernetesJobName provides a mock function with given fields: ctx, deploymentID, jobName
func (_m *DeploymentRepositoryMock) AssignKubernetesJobName(ctx context.Context, deploymentID uuid.UUID, jobName string) (*ent.Deployment, error) {
	ret := _m.Called(ctx, deploymentID, jobName)

	if len(ret) == 0 {
		panic("no return value specified for AssignKubernetesJobName")
	}

	var r0 *ent.Deployment
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string) (*ent.Deployment, error)); ok {
		return rf(ctx, deploymentID, jobName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string) *ent.Deployment); ok {
		r0 = rf(ctx, deploymentID, jobName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ent.Deployment)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, string) error); ok {
		r1 = rf(ctx, deploymentID, jobName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeploymentRepositoryMock_AssignKubernetesJobName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AssignKubernetesJobName'
type DeploymentRepositoryMock_AssignKubernetesJobName_Call struct {
	*mock.Call
}

// AssignKubernetesJobName is a helper method to define mock.On call
//   - ctx context.Context
//   - deploymentID uuid.UUID
//   - jobName string
func (_e *DeploymentRepositoryMock_Expecter) AssignKubernetesJobName(ctx interface{}, deploymentID interface{}, jobName interface{}) *DeploymentRepositoryMock_AssignKubernetesJobName_Call {
	return &DeploymentRepositoryMock_AssignKubernetesJobName_Call{Call: _e.mock.On("AssignKubernetesJobName", ctx, deploymentID, jobName)}
}

func (_c *DeploymentRepositoryMock_AssignKubernetesJobName_Call) Run(run func(ctx context.Context, deploymentID uuid.UUID, jobName string)) *DeploymentRepositoryMock_AssignKubernetesJobName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(string))
	})
	return _c
}

func (_c *DeploymentRepositoryMock_AssignKubernetesJobName_Call) Return(_a0 *ent.Deployment, _a1 error) *DeploymentRepositoryMock_AssignKubernetesJobName_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *DeploymentRepositoryMock_AssignKubernetesJobName_Call) RunAndReturn(run func(context.Context, uuid.UUID, string) (*ent.Deployment, error)) *DeploymentRepositoryMock_AssignKubernetesJobName_Call {
	_c.Call.Return(run)
	return _c
}

// AttachDeploymentMetadata provides a mock function with given fields: ctx, tx, deploymentID, imageName, resourceDefinition
func (_m *DeploymentRepositoryMock) AttachDeploymentMetadata(ctx context.Context, tx repository.TxInterface, deploymentID uuid.UUID, imageName string, resourceDefinition *v1.Service) (*ent.Deployment, error) {
	ret := _m.Called(ctx, tx, deploymentID, imageName, resourceDefinition)

	if len(ret) == 0 {
		panic("no return value specified for AttachDeploymentMetadata")
	}

	var r0 *ent.Deployment
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, repository.TxInterface, uuid.UUID, string, *v1.Service) (*ent.Deployment, error)); ok {
		return rf(ctx, tx, deploymentID, imageName, resourceDefinition)
	}
	if rf, ok := ret.Get(0).(func(context.Context, repository.TxInterface, uuid.UUID, string, *v1.Service) *ent.Deployment); ok {
		r0 = rf(ctx, tx, deploymentID, imageName, resourceDefinition)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ent.Deployment)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, repository.TxInterface, uuid.UUID, string, *v1.Service) error); ok {
		r1 = rf(ctx, tx, deploymentID, imageName, resourceDefinition)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeploymentRepositoryMock_AttachDeploymentMetadata_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AttachDeploymentMetadata'
type DeploymentRepositoryMock_AttachDeploymentMetadata_Call struct {
	*mock.Call
}

// AttachDeploymentMetadata is a helper method to define mock.On call
//   - ctx context.Context
//   - tx repository.TxInterface
//   - deploymentID uuid.UUID
//   - imageName string
//   - resourceDefinition *v1.Service
func (_e *DeploymentRepositoryMock_Expecter) AttachDeploymentMetadata(ctx interface{}, tx interface{}, deploymentID interface{}, imageName interface{}, resourceDefinition interface{}) *DeploymentRepositoryMock_AttachDeploymentMetadata_Call {
	return &DeploymentRepositoryMock_AttachDeploymentMetadata_Call{Call: _e.mock.On("AttachDeploymentMetadata", ctx, tx, deploymentID, imageName, resourceDefinition)}
}

func (_c *DeploymentRepositoryMock_AttachDeploymentMetadata_Call) Run(run func(ctx context.Context, tx repository.TxInterface, deploymentID uuid.UUID, imageName string, resourceDefinition *v1.Service)) *DeploymentRepositoryMock_AttachDeploymentMetadata_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(repository.TxInterface), args[2].(uuid.UUID), args[3].(string), args[4].(*v1.Service))
	})
	return _c
}

func (_c *DeploymentRepositoryMock_AttachDeploymentMetadata_Call) Return(_a0 *ent.Deployment, _a1 error) *DeploymentRepositoryMock_AttachDeploymentMetadata_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *DeploymentRepositoryMock_AttachDeploymentMetadata_Call) RunAndReturn(run func(context.Context, repository.TxInterface, uuid.UUID, string, *v1.Service) (*ent.Deployment, error)) *DeploymentRepositoryMock_AttachDeploymentMetadata_Call {
	_c.Call.Return(run)
	return _c
}

// Create provides a mock function with given fields: ctx, tx, serviceID, CommitSHA, CommitMessage, committer, source
func (_m *DeploymentRepositoryMock) Create(ctx context.Context, tx repository.TxInterface, serviceID uuid.UUID, CommitSHA string, CommitMessage string, committer *schema.GitCommitter, source schema.DeploymentSource) (*ent.Deployment, error) {
	ret := _m.Called(ctx, tx, serviceID, CommitSHA, CommitMessage, committer, source)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 *ent.Deployment
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, repository.TxInterface, uuid.UUID, string, string, *schema.GitCommitter, schema.DeploymentSource) (*ent.Deployment, error)); ok {
		return rf(ctx, tx, serviceID, CommitSHA, CommitMessage, committer, source)
	}
	if rf, ok := ret.Get(0).(func(context.Context, repository.TxInterface, uuid.UUID, string, string, *schema.GitCommitter, schema.DeploymentSource) *ent.Deployment); ok {
		r0 = rf(ctx, tx, serviceID, CommitSHA, CommitMessage, committer, source)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ent.Deployment)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, repository.TxInterface, uuid.UUID, string, string, *schema.GitCommitter, schema.DeploymentSource) error); ok {
		r1 = rf(ctx, tx, serviceID, CommitSHA, CommitMessage, committer, source)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeploymentRepositoryMock_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type DeploymentRepositoryMock_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - tx repository.TxInterface
//   - serviceID uuid.UUID
//   - CommitSHA string
//   - CommitMessage string
//   - committer *schema.GitCommitter
//   - source schema.DeploymentSource
func (_e *DeploymentRepositoryMock_Expecter) Create(ctx interface{}, tx interface{}, serviceID interface{}, CommitSHA interface{}, CommitMessage interface{}, committer interface{}, source interface{}) *DeploymentRepositoryMock_Create_Call {
	return &DeploymentRepositoryMock_Create_Call{Call: _e.mock.On("Create", ctx, tx, serviceID, CommitSHA, CommitMessage, committer, source)}
}

func (_c *DeploymentRepositoryMock_Create_Call) Run(run func(ctx context.Context, tx repository.TxInterface, serviceID uuid.UUID, CommitSHA string, CommitMessage string, committer *schema.GitCommitter, source schema.DeploymentSource)) *DeploymentRepositoryMock_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(repository.TxInterface), args[2].(uuid.UUID), args[3].(string), args[4].(string), args[5].(*schema.GitCommitter), args[6].(schema.DeploymentSource))
	})
	return _c
}

func (_c *DeploymentRepositoryMock_Create_Call) Return(_a0 *ent.Deployment, _a1 error) *DeploymentRepositoryMock_Create_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *DeploymentRepositoryMock_Create_Call) RunAndReturn(run func(context.Context, repository.TxInterface, uuid.UUID, string, string, *schema.GitCommitter, schema.DeploymentSource) (*ent.Deployment, error)) *DeploymentRepositoryMock_Create_Call {
	_c.Call.Return(run)
	return _c
}

// CreateCopy provides a mock function with given fields: ctx, tx, deployment
func (_m *DeploymentRepositoryMock) CreateCopy(ctx context.Context, tx repository.TxInterface, deployment *ent.Deployment) (*ent.Deployment, error) {
	ret := _m.Called(ctx, tx, deployment)

	if len(ret) == 0 {
		panic("no return value specified for CreateCopy")
	}

	var r0 *ent.Deployment
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, repository.TxInterface, *ent.Deployment) (*ent.Deployment, error)); ok {
		return rf(ctx, tx, deployment)
	}
	if rf, ok := ret.Get(0).(func(context.Context, repository.TxInterface, *ent.Deployment) *ent.Deployment); ok {
		r0 = rf(ctx, tx, deployment)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ent.Deployment)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, repository.TxInterface, *ent.Deployment) error); ok {
		r1 = rf(ctx, tx, deployment)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeploymentRepositoryMock_CreateCopy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateCopy'
type DeploymentRepositoryMock_CreateCopy_Call struct {
	*mock.Call
}

// CreateCopy is a helper method to define mock.On call
//   - ctx context.Context
//   - tx repository.TxInterface
//   - deployment *ent.Deployment
func (_e *DeploymentRepositoryMock_Expecter) CreateCopy(ctx interface{}, tx interface{}, deployment interface{}) *DeploymentRepositoryMock_CreateCopy_Call {
	return &DeploymentRepositoryMock_CreateCopy_Call{Call: _e.mock.On("CreateCopy", ctx, tx, deployment)}
}

func (_c *DeploymentRepositoryMock_CreateCopy_Call) Run(run func(ctx context.Context, tx repository.TxInterface, deployment *ent.Deployment)) *DeploymentRepositoryMock_CreateCopy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(repository.TxInterface), args[2].(*ent.Deployment))
	})
	return _c
}

func (_c *DeploymentRepositoryMock_CreateCopy_Call) Return(_a0 *ent.Deployment, _a1 error) *DeploymentRepositoryMock_CreateCopy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *DeploymentRepositoryMock_CreateCopy_Call) RunAndReturn(run func(context.Context, repository.TxInterface, *ent.Deployment) (*ent.Deployment, error)) *DeploymentRepositoryMock_CreateCopy_Call {
	_c.Call.Return(run)
	return _c
}

// ExistsInEnvironment provides a mock function with given fields: ctx, deploymentID, environmentID
func (_m *DeploymentRepositoryMock) ExistsInEnvironment(ctx context.Context, deploymentID uuid.UUID, environmentID uuid.UUID) (bool, error) {
	ret := _m.Called(ctx, deploymentID, environmentID)

	if len(ret) == 0 {
		panic("no return value specified for ExistsInEnvironment")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID) (bool, error)); ok {
		return rf(ctx, deploymentID, environmentID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID) bool); ok {
		r0 = rf(ctx, deploymentID, environmentID)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID) error); ok {
		r1 = rf(ctx, deploymentID, environmentID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeploymentRepositoryMock_ExistsInEnvironment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExistsInEnvironment'
type DeploymentRepositoryMock_ExistsInEnvironment_Call struct {
	*mock.Call
}

// ExistsInEnvironment is a helper method to define mock.On call
//   - ctx context.Context
//   - deploymentID uuid.UUID
//   - environmentID uuid.UUID
func (_e *DeploymentRepositoryMock_Expecter) ExistsInEnvironment(ctx interface{}, deploymentID interface{}, environmentID interface{}) *DeploymentRepositoryMock_ExistsInEnvironment_Call {
	return &DeploymentRepositoryMock_ExistsInEnvironment_Call{Call: _e.mock.On("ExistsInEnvironment", ctx, deploymentID, environmentID)}
}

func (_c *DeploymentRepositoryMock_ExistsInEnvironment_Call) Run(run func(ctx context.Context, deploymentID uuid.UUID, environmentID uuid.UUID)) *DeploymentRepositoryMock_ExistsInEnvironment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID))
	})
	return _c
}

func (_c *DeploymentRepositoryMock_ExistsInEnvironment_Call) Return(_a0 bool, _a1 error) *DeploymentRepositoryMock_ExistsInEnvironment_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *DeploymentRepositoryMock_ExistsInEnvironment_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID) (bool, error)) *DeploymentRepositoryMock_ExistsInEnvironment_Call {
	_c.Call.Return(run)
	return _c
}

// ExistsInProject provides a mock function with given fields: ctx, deploymentID, projectID
func (_m *DeploymentRepositoryMock) ExistsInProject(ctx context.Context, deploymentID uuid.UUID, projectID uuid.UUID) (bool, error) {
	ret := _m.Called(ctx, deploymentID, projectID)

	if len(ret) == 0 {
		panic("no return value specified for ExistsInProject")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID) (bool, error)); ok {
		return rf(ctx, deploymentID, projectID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID) bool); ok {
		r0 = rf(ctx, deploymentID, projectID)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID) error); ok {
		r1 = rf(ctx, deploymentID, projectID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeploymentRepositoryMock_ExistsInProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExistsInProject'
type DeploymentRepositoryMock_ExistsInProject_Call struct {
	*mock.Call
}

// ExistsInProject is a helper method to define mock.On call
//   - ctx context.Context
//   - deploymentID uuid.UUID
//   - projectID uuid.UUID
func (_e *DeploymentRepositoryMock_Expecter) ExistsInProject(ctx interface{}, deploymentID interface{}, projectID interface{}) *DeploymentRepositoryMock_ExistsInProject_Call {
	return &DeploymentRepositoryMock_ExistsInProject_Call{Call: _e.mock.On("ExistsInProject", ctx, deploymentID, projectID)}
}

func (_c *DeploymentRepositoryMock_ExistsInProject_Call) Run(run func(ctx context.Context, deploymentID uuid.UUID, projectID uuid.UUID)) *DeploymentRepositoryMock_ExistsInProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID))
	})
	return _c
}

func (_c *DeploymentRepositoryMock_ExistsInProject_Call) Return(_a0 bool, _a1 error) *DeploymentRepositoryMock_ExistsInProject_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *DeploymentRepositoryMock_ExistsInProject_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID) (bool, error)) *DeploymentRepositoryMock_ExistsInProject_Call {
	_c.Call.Return(run)
	return _c
}

// ExistsInTeam provides a mock function with given fields: ctx, deploymentID, teamID
func (_m *DeploymentRepositoryMock) ExistsInTeam(ctx context.Context, deploymentID uuid.UUID, teamID uuid.UUID) (bool, error) {
	ret := _m.Called(ctx, deploymentID, teamID)

	if len(ret) == 0 {
		panic("no return value specified for ExistsInTeam")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID) (bool, error)); ok {
		return rf(ctx, deploymentID, teamID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID) bool); ok {
		r0 = rf(ctx, deploymentID, teamID)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, uuid.UUID) error); ok {
		r1 = rf(ctx, deploymentID, teamID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeploymentRepositoryMock_ExistsInTeam_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExistsInTeam'
type DeploymentRepositoryMock_ExistsInTeam_Call struct {
	*mock.Call
}

// ExistsInTeam is a helper method to define mock.On call
//   - ctx context.Context
//   - deploymentID uuid.UUID
//   - teamID uuid.UUID
func (_e *DeploymentRepositoryMock_Expecter) ExistsInTeam(ctx interface{}, deploymentID interface{}, teamID interface{}) *DeploymentRepositoryMock_ExistsInTeam_Call {
	return &DeploymentRepositoryMock_ExistsInTeam_Call{Call: _e.mock.On("ExistsInTeam", ctx, deploymentID, teamID)}
}

func (_c *DeploymentRepositoryMock_ExistsInTeam_Call) Run(run func(ctx context.Context, deploymentID uuid.UUID, teamID uuid.UUID)) *DeploymentRepositoryMock_ExistsInTeam_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID))
	})
	return _c
}

func (_c *DeploymentRepositoryMock_ExistsInTeam_Call) Return(_a0 bool, _a1 error) *DeploymentRepositoryMock_ExistsInTeam_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *DeploymentRepositoryMock_ExistsInTeam_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID) (bool, error)) *DeploymentRepositoryMock_ExistsInTeam_Call {
	_c.Call.Return(run)
	return _c
}

// GetByID provides a mock function with given fields: ctx, deploymentID
func (_m *DeploymentRepositoryMock) GetByID(ctx context.Context, deploymentID uuid.UUID) (*ent.Deployment, error) {
	ret := _m.Called(ctx, deploymentID)

	if len(ret) == 0 {
		panic("no return value specified for GetByID")
	}

	var r0 *ent.Deployment
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*ent.Deployment, error)); ok {
		return rf(ctx, deploymentID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) *ent.Deployment); ok {
		r0 = rf(ctx, deploymentID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ent.Deployment)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, deploymentID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeploymentRepositoryMock_GetByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByID'
type DeploymentRepositoryMock_GetByID_Call struct {
	*mock.Call
}

// GetByID is a helper method to define mock.On call
//   - ctx context.Context
//   - deploymentID uuid.UUID
func (_e *DeploymentRepositoryMock_Expecter) GetByID(ctx interface{}, deploymentID interface{}) *DeploymentRepositoryMock_GetByID_Call {
	return &DeploymentRepositoryMock_GetByID_Call{Call: _e.mock.On("GetByID", ctx, deploymentID)}
}

func (_c *DeploymentRepositoryMock_GetByID_Call) Run(run func(ctx context.Context, deploymentID uuid.UUID)) *DeploymentRepositoryMock_GetByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *DeploymentRepositoryMock_GetByID_Call) Return(_a0 *ent.Deployment, _a1 error) *DeploymentRepositoryMock_GetByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *DeploymentRepositoryMock_GetByID_Call) RunAndReturn(run func(context.Context, uuid.UUID) (*ent.Deployment, error)) *DeploymentRepositoryMock_GetByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetByServiceIDPaginated provides a mock function with given fields: ctx, serviceID, perPage, cursor, statusFilter
func (_m *DeploymentRepositoryMock) GetByServiceIDPaginated(ctx context.Context, serviceID uuid.UUID, perPage int, cursor *time.Time, statusFilter []schema.DeploymentStatus) ([]*ent.Deployment, *time.Time, error) {
	ret := _m.Called(ctx, serviceID, perPage, cursor, statusFilter)

	if len(ret) == 0 {
		panic("no return value specified for GetByServiceIDPaginated")
	}

	var r0 []*ent.Deployment
	var r1 *time.Time
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, int, *time.Time, []schema.DeploymentStatus) ([]*ent.Deployment, *time.Time, error)); ok {
		return rf(ctx, serviceID, perPage, cursor, statusFilter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, int, *time.Time, []schema.DeploymentStatus) []*ent.Deployment); ok {
		r0 = rf(ctx, serviceID, perPage, cursor, statusFilter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*ent.Deployment)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, int, *time.Time, []schema.DeploymentStatus) *time.Time); ok {
		r1 = rf(ctx, serviceID, perPage, cursor, statusFilter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*time.Time)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, uuid.UUID, int, *time.Time, []schema.DeploymentStatus) error); ok {
		r2 = rf(ctx, serviceID, perPage, cursor, statusFilter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// DeploymentRepositoryMock_GetByServiceIDPaginated_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByServiceIDPaginated'
type DeploymentRepositoryMock_GetByServiceIDPaginated_Call struct {
	*mock.Call
}

// GetByServiceIDPaginated is a helper method to define mock.On call
//   - ctx context.Context
//   - serviceID uuid.UUID
//   - perPage int
//   - cursor *time.Time
//   - statusFilter []schema.DeploymentStatus
func (_e *DeploymentRepositoryMock_Expecter) GetByServiceIDPaginated(ctx interface{}, serviceID interface{}, perPage interface{}, cursor interface{}, statusFilter interface{}) *DeploymentRepositoryMock_GetByServiceIDPaginated_Call {
	return &DeploymentRepositoryMock_GetByServiceIDPaginated_Call{Call: _e.mock.On("GetByServiceIDPaginated", ctx, serviceID, perPage, cursor, statusFilter)}
}

func (_c *DeploymentRepositoryMock_GetByServiceIDPaginated_Call) Run(run func(ctx context.Context, serviceID uuid.UUID, perPage int, cursor *time.Time, statusFilter []schema.DeploymentStatus)) *DeploymentRepositoryMock_GetByServiceIDPaginated_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(int), args[3].(*time.Time), args[4].([]schema.DeploymentStatus))
	})
	return _c
}

func (_c *DeploymentRepositoryMock_GetByServiceIDPaginated_Call) Return(jobs []*ent.Deployment, nextCursor *time.Time, err error) *DeploymentRepositoryMock_GetByServiceIDPaginated_Call {
	_c.Call.Return(jobs, nextCursor, err)
	return _c
}

func (_c *DeploymentRepositoryMock_GetByServiceIDPaginated_Call) RunAndReturn(run func(context.Context, uuid.UUID, int, *time.Time, []schema.DeploymentStatus) ([]*ent.Deployment, *time.Time, error)) *DeploymentRepositoryMock_GetByServiceIDPaginated_Call {
	_c.Call.Return(run)
	return _c
}

// GetJobsByStatus provides a mock function with given fields: ctx, status
func (_m *DeploymentRepositoryMock) GetJobsByStatus(ctx context.Context, status schema.DeploymentStatus) ([]*ent.Deployment, error) {
	ret := _m.Called(ctx, status)

	if len(ret) == 0 {
		panic("no return value specified for GetJobsByStatus")
	}

	var r0 []*ent.Deployment
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, schema.DeploymentStatus) ([]*ent.Deployment, error)); ok {
		return rf(ctx, status)
	}
	if rf, ok := ret.Get(0).(func(context.Context, schema.DeploymentStatus) []*ent.Deployment); ok {
		r0 = rf(ctx, status)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*ent.Deployment)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, schema.DeploymentStatus) error); ok {
		r1 = rf(ctx, status)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeploymentRepositoryMock_GetJobsByStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetJobsByStatus'
type DeploymentRepositoryMock_GetJobsByStatus_Call struct {
	*mock.Call
}

// GetJobsByStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - status schema.DeploymentStatus
func (_e *DeploymentRepositoryMock_Expecter) GetJobsByStatus(ctx interface{}, status interface{}) *DeploymentRepositoryMock_GetJobsByStatus_Call {
	return &DeploymentRepositoryMock_GetJobsByStatus_Call{Call: _e.mock.On("GetJobsByStatus", ctx, status)}
}

func (_c *DeploymentRepositoryMock_GetJobsByStatus_Call) Run(run func(ctx context.Context, status schema.DeploymentStatus)) *DeploymentRepositoryMock_GetJobsByStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(schema.DeploymentStatus))
	})
	return _c
}

func (_c *DeploymentRepositoryMock_GetJobsByStatus_Call) Return(_a0 []*ent.Deployment, _a1 error) *DeploymentRepositoryMock_GetJobsByStatus_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *DeploymentRepositoryMock_GetJobsByStatus_Call) RunAndReturn(run func(context.Context, schema.DeploymentStatus) ([]*ent.Deployment, error)) *DeploymentRepositoryMock_GetJobsByStatus_Call {
	_c.Call.Return(run)
	return _c
}

// GetLastSuccessfulDeployment provides a mock function with given fields: ctx, serviceID
func (_m *DeploymentRepositoryMock) GetLastSuccessfulDeployment(ctx context.Context, serviceID uuid.UUID) (*ent.Deployment, error) {
	ret := _m.Called(ctx, serviceID)

	if len(ret) == 0 {
		panic("no return value specified for GetLastSuccessfulDeployment")
	}

	var r0 *ent.Deployment
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*ent.Deployment, error)); ok {
		return rf(ctx, serviceID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) *ent.Deployment); ok {
		r0 = rf(ctx, serviceID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ent.Deployment)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, serviceID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeploymentRepositoryMock_GetLastSuccessfulDeployment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLastSuccessfulDeployment'
type DeploymentRepositoryMock_GetLastSuccessfulDeployment_Call struct {
	*mock.Call
}

// GetLastSuccessfulDeployment is a helper method to define mock.On call
//   - ctx context.Context
//   - serviceID uuid.UUID
func (_e *DeploymentRepositoryMock_Expecter) GetLastSuccessfulDeployment(ctx interface{}, serviceID interface{}) *DeploymentRepositoryMock_GetLastSuccessfulDeployment_Call {
	return &DeploymentRepositoryMock_GetLastSuccessfulDeployment_Call{Call: _e.mock.On("GetLastSuccessfulDeployment", ctx, serviceID)}
}

func (_c *DeploymentRepositoryMock_GetLastSuccessfulDeployment_Call) Run(run func(ctx context.Context, serviceID uuid.UUID)) *DeploymentRepositoryMock_GetLastSuccessfulDeployment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *DeploymentRepositoryMock_GetLastSuccessfulDeployment_Call) Return(_a0 *ent.Deployment, _a1 error) *DeploymentRepositoryMock_GetLastSuccessfulDeployment_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *DeploymentRepositoryMock_GetLastSuccessfulDeployment_Call) RunAndReturn(run func(context.Context, uuid.UUID) (*ent.Deployment, error)) *DeploymentRepositoryMock_GetLastSuccessfulDeployment_Call {
	_c.Call.Return(run)
	return _c
}

// MarkAsCancelled provides a mock function with given fields: ctx, jobIDs
func (_m *DeploymentRepositoryMock) MarkAsCancelled(ctx context.Context, jobIDs []uuid.UUID) error {
	ret := _m.Called(ctx, jobIDs)

	if len(ret) == 0 {
		panic("no return value specified for MarkAsCancelled")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []uuid.UUID) error); ok {
		r0 = rf(ctx, jobIDs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeploymentRepositoryMock_MarkAsCancelled_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MarkAsCancelled'
type DeploymentRepositoryMock_MarkAsCancelled_Call struct {
	*mock.Call
}

// MarkAsCancelled is a helper method to define mock.On call
//   - ctx context.Context
//   - jobIDs []uuid.UUID
func (_e *DeploymentRepositoryMock_Expecter) MarkAsCancelled(ctx interface{}, jobIDs interface{}) *DeploymentRepositoryMock_MarkAsCancelled_Call {
	return &DeploymentRepositoryMock_MarkAsCancelled_Call{Call: _e.mock.On("MarkAsCancelled", ctx, jobIDs)}
}

func (_c *DeploymentRepositoryMock_MarkAsCancelled_Call) Run(run func(ctx context.Context, jobIDs []uuid.UUID)) *DeploymentRepositoryMock_MarkAsCancelled_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]uuid.UUID))
	})
	return _c
}

func (_c *DeploymentRepositoryMock_MarkAsCancelled_Call) Return(_a0 error) *DeploymentRepositoryMock_MarkAsCancelled_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *DeploymentRepositoryMock_MarkAsCancelled_Call) RunAndReturn(run func(context.Context, []uuid.UUID) error) *DeploymentRepositoryMock_MarkAsCancelled_Call {
	_c.Call.Return(run)
	return _c
}

// MarkCancelledExcept provides a mock function with given fields: ctx, serviceID, deploymentID
func (_m *DeploymentRepositoryMock) MarkCancelledExcept(ctx context.Context, serviceID uuid.UUID, deploymentID uuid.UUID) error {
	ret := _m.Called(ctx, serviceID, deploymentID)

	if len(ret) == 0 {
		panic("no return value specified for MarkCancelledExcept")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID) error); ok {
		r0 = rf(ctx, serviceID, deploymentID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeploymentRepositoryMock_MarkCancelledExcept_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MarkCancelledExcept'
type DeploymentRepositoryMock_MarkCancelledExcept_Call struct {
	*mock.Call
}

// MarkCancelledExcept is a helper method to define mock.On call
//   - ctx context.Context
//   - serviceID uuid.UUID
//   - deploymentID uuid.UUID
func (_e *DeploymentRepositoryMock_Expecter) MarkCancelledExcept(ctx interface{}, serviceID interface{}, deploymentID interface{}) *DeploymentRepositoryMock_MarkCancelledExcept_Call {
	return &DeploymentRepositoryMock_MarkCancelledExcept_Call{Call: _e.mock.On("MarkCancelledExcept", ctx, serviceID, deploymentID)}
}

func (_c *DeploymentRepositoryMock_MarkCancelledExcept_Call) Run(run func(ctx context.Context, serviceID uuid.UUID, deploymentID uuid.UUID)) *DeploymentRepositoryMock_MarkCancelledExcept_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID))
	})
	return _c
}

func (_c *DeploymentRepositoryMock_MarkCancelledExcept_Call) Return(_a0 error) *DeploymentRepositoryMock_MarkCancelledExcept_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *DeploymentRepositoryMock_MarkCancelledExcept_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID) error) *DeploymentRepositoryMock_MarkCancelledExcept_Call {
	_c.Call.Return(run)
	return _c
}

// MarkFailed provides a mock function with given fields: ctx, tx, deploymentID, message, failedAt
func (_m *DeploymentRepositoryMock) MarkFailed(ctx context.Context, tx repository.TxInterface, deploymentID uuid.UUID, message string, failedAt time.Time) (*ent.Deployment, error) {
	ret := _m.Called(ctx, tx, deploymentID, message, failedAt)

	if len(ret) == 0 {
		panic("no return value specified for MarkFailed")
	}

	var r0 *ent.Deployment
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, repository.TxInterface, uuid.UUID, string, time.Time) (*ent.Deployment, error)); ok {
		return rf(ctx, tx, deploymentID, message, failedAt)
	}
	if rf, ok := ret.Get(0).(func(context.Context, repository.TxInterface, uuid.UUID, string, time.Time) *ent.Deployment); ok {
		r0 = rf(ctx, tx, deploymentID, message, failedAt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ent.Deployment)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, repository.TxInterface, uuid.UUID, string, time.Time) error); ok {
		r1 = rf(ctx, tx, deploymentID, message, failedAt)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeploymentRepositoryMock_MarkFailed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MarkFailed'
type DeploymentRepositoryMock_MarkFailed_Call struct {
	*mock.Call
}

// MarkFailed is a helper method to define mock.On call
//   - ctx context.Context
//   - tx repository.TxInterface
//   - deploymentID uuid.UUID
//   - message string
//   - failedAt time.Time
func (_e *DeploymentRepositoryMock_Expecter) MarkFailed(ctx interface{}, tx interface{}, deploymentID interface{}, message interface{}, failedAt interface{}) *DeploymentRepositoryMock_MarkFailed_Call {
	return &DeploymentRepositoryMock_MarkFailed_Call{Call: _e.mock.On("MarkFailed", ctx, tx, deploymentID, message, failedAt)}
}

func (_c *DeploymentRepositoryMock_MarkFailed_Call) Run(run func(ctx context.Context, tx repository.TxInterface, deploymentID uuid.UUID, message string, failedAt time.Time)) *DeploymentRepositoryMock_MarkFailed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(repository.TxInterface), args[2].(uuid.UUID), args[3].(string), args[4].(time.Time))
	})
	return _c
}

func (_c *DeploymentRepositoryMock_MarkFailed_Call) Return(_a0 *ent.Deployment, _a1 error) *DeploymentRepositoryMock_MarkFailed_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *DeploymentRepositoryMock_MarkFailed_Call) RunAndReturn(run func(context.Context, repository.TxInterface, uuid.UUID, string, time.Time) (*ent.Deployment, error)) *DeploymentRepositoryMock_MarkFailed_Call {
	_c.Call.Return(run)
	return _c
}

// MarkStarted provides a mock function with given fields: ctx, tx, deploymentID, startedAt
func (_m *DeploymentRepositoryMock) MarkStarted(ctx context.Context, tx repository.TxInterface, deploymentID uuid.UUID, startedAt time.Time) (*ent.Deployment, error) {
	ret := _m.Called(ctx, tx, deploymentID, startedAt)

	if len(ret) == 0 {
		panic("no return value specified for MarkStarted")
	}

	var r0 *ent.Deployment
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, repository.TxInterface, uuid.UUID, time.Time) (*ent.Deployment, error)); ok {
		return rf(ctx, tx, deploymentID, startedAt)
	}
	if rf, ok := ret.Get(0).(func(context.Context, repository.TxInterface, uuid.UUID, time.Time) *ent.Deployment); ok {
		r0 = rf(ctx, tx, deploymentID, startedAt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ent.Deployment)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, repository.TxInterface, uuid.UUID, time.Time) error); ok {
		r1 = rf(ctx, tx, deploymentID, startedAt)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeploymentRepositoryMock_MarkStarted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MarkStarted'
type DeploymentRepositoryMock_MarkStarted_Call struct {
	*mock.Call
}

// MarkStarted is a helper method to define mock.On call
//   - ctx context.Context
//   - tx repository.TxInterface
//   - deploymentID uuid.UUID
//   - startedAt time.Time
func (_e *DeploymentRepositoryMock_Expecter) MarkStarted(ctx interface{}, tx interface{}, deploymentID interface{}, startedAt interface{}) *DeploymentRepositoryMock_MarkStarted_Call {
	return &DeploymentRepositoryMock_MarkStarted_Call{Call: _e.mock.On("MarkStarted", ctx, tx, deploymentID, startedAt)}
}

func (_c *DeploymentRepositoryMock_MarkStarted_Call) Run(run func(ctx context.Context, tx repository.TxInterface, deploymentID uuid.UUID, startedAt time.Time)) *DeploymentRepositoryMock_MarkStarted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(repository.TxInterface), args[2].(uuid.UUID), args[3].(time.Time))
	})
	return _c
}

func (_c *DeploymentRepositoryMock_MarkStarted_Call) Return(_a0 *ent.Deployment, _a1 error) *DeploymentRepositoryMock_MarkStarted_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *DeploymentRepositoryMock_MarkStarted_Call) RunAndReturn(run func(context.Context, repository.TxInterface, uuid.UUID, time.Time) (*ent.Deployment, error)) *DeploymentRepositoryMock_MarkStarted_Call {
	_c.Call.Return(run)
	return _c
}

// MarkSucceeded provides a mock function with given fields: ctx, tx, deploymentID, completedAt
func (_m *DeploymentRepositoryMock) MarkSucceeded(ctx context.Context, tx repository.TxInterface, deploymentID uuid.UUID, completedAt time.Time) (*ent.Deployment, error) {
	ret := _m.Called(ctx, tx, deploymentID, completedAt)

	if len(ret) == 0 {
		panic("no return value specified for MarkSucceeded")
	}

	var r0 *ent.Deployment
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, repository.TxInterface, uuid.UUID, time.Time) (*ent.Deployment, error)); ok {
		return rf(ctx, tx, deploymentID, completedAt)
	}
	if rf, ok := ret.Get(0).(func(context.Context, repository.TxInterface, uuid.UUID, time.Time) *ent.Deployment); ok {
		r0 = rf(ctx, tx, deploymentID, completedAt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ent.Deployment)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, repository.TxInterface, uuid.UUID, time.Time) error); ok {
		r1 = rf(ctx, tx, deploymentID, completedAt)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeploymentRepositoryMock_MarkSucceeded_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MarkSucceeded'
type DeploymentRepositoryMock_MarkSucceeded_Call struct {
	*mock.Call
}

// MarkSucceeded is a helper method to define mock.On call
//   - ctx context.Context
//   - tx repository.TxInterface
//   - deploymentID uuid.UUID
//   - completedAt time.Time
func (_e *DeploymentRepositoryMock_Expecter) MarkSucceeded(ctx interface{}, tx interface{}, deploymentID interface{}, completedAt interface{}) *DeploymentRepositoryMock_MarkSucceeded_Call {
	return &DeploymentRepositoryMock_MarkSucceeded_Call{Call: _e.mock.On("MarkSucceeded", ctx, tx, deploymentID, completedAt)}
}

func (_c *DeploymentRepositoryMock_MarkSucceeded_Call) Run(run func(ctx context.Context, tx repository.TxInterface, deploymentID uuid.UUID, completedAt time.Time)) *DeploymentRepositoryMock_MarkSucceeded_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(repository.TxInterface), args[2].(uuid.UUID), args[3].(time.Time))
	})
	return _c
}

func (_c *DeploymentRepositoryMock_MarkSucceeded_Call) Return(_a0 *ent.Deployment, _a1 error) *DeploymentRepositoryMock_MarkSucceeded_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *DeploymentRepositoryMock_MarkSucceeded_Call) RunAndReturn(run func(context.Context, repository.TxInterface, uuid.UUID, time.Time) (*ent.Deployment, error)) *DeploymentRepositoryMock_MarkSucceeded_Call {
	_c.Call.Return(run)
	return _c
}

// SetKubernetesJobStatus provides a mock function with given fields: ctx, deploymentID, status
func (_m *DeploymentRepositoryMock) SetKubernetesJobStatus(ctx context.Context, deploymentID uuid.UUID, status string) (*ent.Deployment, error) {
	ret := _m.Called(ctx, deploymentID, status)

	if len(ret) == 0 {
		panic("no return value specified for SetKubernetesJobStatus")
	}

	var r0 *ent.Deployment
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string) (*ent.Deployment, error)); ok {
		return rf(ctx, deploymentID, status)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string) *ent.Deployment); ok {
		r0 = rf(ctx, deploymentID, status)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ent.Deployment)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, string) error); ok {
		r1 = rf(ctx, deploymentID, status)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeploymentRepositoryMock_SetKubernetesJobStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetKubernetesJobStatus'
type DeploymentRepositoryMock_SetKubernetesJobStatus_Call struct {
	*mock.Call
}

// SetKubernetesJobStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - deploymentID uuid.UUID
//   - status string
func (_e *DeploymentRepositoryMock_Expecter) SetKubernetesJobStatus(ctx interface{}, deploymentID interface{}, status interface{}) *DeploymentRepositoryMock_SetKubernetesJobStatus_Call {
	return &DeploymentRepositoryMock_SetKubernetesJobStatus_Call{Call: _e.mock.On("SetKubernetesJobStatus", ctx, deploymentID, status)}
}

func (_c *DeploymentRepositoryMock_SetKubernetesJobStatus_Call) Run(run func(ctx context.Context, deploymentID uuid.UUID, status string)) *DeploymentRepositoryMock_SetKubernetesJobStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(string))
	})
	return _c
}

func (_c *DeploymentRepositoryMock_SetKubernetesJobStatus_Call) Return(_a0 *ent.Deployment, _a1 error) *DeploymentRepositoryMock_SetKubernetesJobStatus_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *DeploymentRepositoryMock_SetKubernetesJobStatus_Call) RunAndReturn(run func(context.Context, uuid.UUID, string) (*ent.Deployment, error)) *DeploymentRepositoryMock_SetKubernetesJobStatus_Call {
	_c.Call.Return(run)
	return _c
}

// NewDeploymentRepositoryMock creates a new instance of DeploymentRepositoryMock. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewDeploymentRepositoryMock(t interface {
	mock.TestingT
	Cleanup(func())
}) *DeploymentRepositoryMock {
	mock := &DeploymentRepositoryMock{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
