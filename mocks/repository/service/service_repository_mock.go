// Code generated by mockery v2.53.4. DO NOT EDIT.

package mocks_repository_service

import (
	context "context"

	mock "github.com/stretchr/testify/mock"
	ent "github.com/unbindapp/unbind-api/ent"

	models "github.com/unbindapp/unbind-api/internal/models"

	predicate "github.com/unbindapp/unbind-api/ent/predicate"

	repository "github.com/unbindapp/unbind-api/internal/repositories"

	schema "github.com/unbindapp/unbind-api/ent/schema"

	service_repo "github.com/unbindapp/unbind-api/internal/repositories/service"

	uuid "github.com/google/uuid"
)

// ServiceRepositoryMock is an autogenerated mock type for the ServiceRepositoryInterface type
type ServiceRepositoryMock struct {
	mock.Mock
}

type ServiceRepositoryMock_Expecter struct {
	mock *mock.Mock
}

func (_m *ServiceRepositoryMock) EXPECT() *ServiceRepositoryMock_Expecter {
	return &ServiceRepositoryMock_Expecter{mock: &_m.Mock}
}

// CountDomainCollisons provides a mock function with given fields: ctx, tx, domain
func (_m *ServiceRepositoryMock) CountDomainCollisons(ctx context.Context, tx repository.TxInterface, domain string) (int, error) {
	ret := _m.Called(ctx, tx, domain)

	if len(ret) == 0 {
		panic("no return value specified for CountDomainCollisons")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, repository.TxInterface, string) (int, error)); ok {
		return rf(ctx, tx, domain)
	}
	if rf, ok := ret.Get(0).(func(context.Context, repository.TxInterface, string) int); ok {
		r0 = rf(ctx, tx, domain)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context, repository.TxInterface, string) error); ok {
		r1 = rf(ctx, tx, domain)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ServiceRepositoryMock_CountDomainCollisons_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountDomainCollisons'
type ServiceRepositoryMock_CountDomainCollisons_Call struct {
	*mock.Call
}

// CountDomainCollisons is a helper method to define mock.On call
//   - ctx context.Context
//   - tx repository.TxInterface
//   - domain string
func (_e *ServiceRepositoryMock_Expecter) CountDomainCollisons(ctx interface{}, tx interface{}, domain interface{}) *ServiceRepositoryMock_CountDomainCollisons_Call {
	return &ServiceRepositoryMock_CountDomainCollisons_Call{Call: _e.mock.On("CountDomainCollisons", ctx, tx, domain)}
}

func (_c *ServiceRepositoryMock_CountDomainCollisons_Call) Run(run func(ctx context.Context, tx repository.TxInterface, domain string)) *ServiceRepositoryMock_CountDomainCollisons_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(repository.TxInterface), args[2].(string))
	})
	return _c
}

func (_c *ServiceRepositoryMock_CountDomainCollisons_Call) Return(_a0 int, _a1 error) *ServiceRepositoryMock_CountDomainCollisons_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ServiceRepositoryMock_CountDomainCollisons_Call) RunAndReturn(run func(context.Context, repository.TxInterface, string) (int, error)) *ServiceRepositoryMock_CountDomainCollisons_Call {
	_c.Call.Return(run)
	return _c
}

// CountDomainCollisonsExcludingServiceID provides a mock function with given fields: ctx, tx, domain, serviceID
func (_m *ServiceRepositoryMock) CountDomainCollisonsExcludingServiceID(ctx context.Context, tx repository.TxInterface, domain string, serviceID uuid.UUID) (int, error) {
	ret := _m.Called(ctx, tx, domain, serviceID)

	if len(ret) == 0 {
		panic("no return value specified for CountDomainCollisonsExcludingServiceID")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, repository.TxInterface, string, uuid.UUID) (int, error)); ok {
		return rf(ctx, tx, domain, serviceID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, repository.TxInterface, string, uuid.UUID) int); ok {
		r0 = rf(ctx, tx, domain, serviceID)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context, repository.TxInterface, string, uuid.UUID) error); ok {
		r1 = rf(ctx, tx, domain, serviceID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ServiceRepositoryMock_CountDomainCollisonsExcludingServiceID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountDomainCollisonsExcludingServiceID'
type ServiceRepositoryMock_CountDomainCollisonsExcludingServiceID_Call struct {
	*mock.Call
}

// CountDomainCollisonsExcludingServiceID is a helper method to define mock.On call
//   - ctx context.Context
//   - tx repository.TxInterface
//   - domain string
//   - serviceID uuid.UUID
func (_e *ServiceRepositoryMock_Expecter) CountDomainCollisonsExcludingServiceID(ctx interface{}, tx interface{}, domain interface{}, serviceID interface{}) *ServiceRepositoryMock_CountDomainCollisonsExcludingServiceID_Call {
	return &ServiceRepositoryMock_CountDomainCollisonsExcludingServiceID_Call{Call: _e.mock.On("CountDomainCollisonsExcludingServiceID", ctx, tx, domain, serviceID)}
}

func (_c *ServiceRepositoryMock_CountDomainCollisonsExcludingServiceID_Call) Run(run func(ctx context.Context, tx repository.TxInterface, domain string, serviceID uuid.UUID)) *ServiceRepositoryMock_CountDomainCollisonsExcludingServiceID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(repository.TxInterface), args[2].(string), args[3].(uuid.UUID))
	})
	return _c
}

func (_c *ServiceRepositoryMock_CountDomainCollisonsExcludingServiceID_Call) Return(_a0 int, _a1 error) *ServiceRepositoryMock_CountDomainCollisonsExcludingServiceID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ServiceRepositoryMock_CountDomainCollisonsExcludingServiceID_Call) RunAndReturn(run func(context.Context, repository.TxInterface, string, uuid.UUID) (int, error)) *ServiceRepositoryMock_CountDomainCollisonsExcludingServiceID_Call {
	_c.Call.Return(run)
	return _c
}

// Create provides a mock function with given fields: ctx, tx, input
func (_m *ServiceRepositoryMock) Create(ctx context.Context, tx repository.TxInterface, input *service_repo.CreateServiceInput) (*ent.Service, error) {
	ret := _m.Called(ctx, tx, input)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 *ent.Service
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, repository.TxInterface, *service_repo.CreateServiceInput) (*ent.Service, error)); ok {
		return rf(ctx, tx, input)
	}
	if rf, ok := ret.Get(0).(func(context.Context, repository.TxInterface, *service_repo.CreateServiceInput) *ent.Service); ok {
		r0 = rf(ctx, tx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ent.Service)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, repository.TxInterface, *service_repo.CreateServiceInput) error); ok {
		r1 = rf(ctx, tx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ServiceRepositoryMock_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type ServiceRepositoryMock_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - tx repository.TxInterface
//   - input *service_repo.CreateServiceInput
func (_e *ServiceRepositoryMock_Expecter) Create(ctx interface{}, tx interface{}, input interface{}) *ServiceRepositoryMock_Create_Call {
	return &ServiceRepositoryMock_Create_Call{Call: _e.mock.On("Create", ctx, tx, input)}
}

func (_c *ServiceRepositoryMock_Create_Call) Run(run func(ctx context.Context, tx repository.TxInterface, input *service_repo.CreateServiceInput)) *ServiceRepositoryMock_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(repository.TxInterface), args[2].(*service_repo.CreateServiceInput))
	})
	return _c
}

func (_c *ServiceRepositoryMock_Create_Call) Return(_a0 *ent.Service, _a1 error) *ServiceRepositoryMock_Create_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ServiceRepositoryMock_Create_Call) RunAndReturn(run func(context.Context, repository.TxInterface, *service_repo.CreateServiceInput) (*ent.Service, error)) *ServiceRepositoryMock_Create_Call {
	_c.Call.Return(run)
	return _c
}

// CreateConfig provides a mock function with given fields: ctx, tx, input
func (_m *ServiceRepositoryMock) CreateConfig(ctx context.Context, tx repository.TxInterface, input *service_repo.MutateConfigInput) (*ent.ServiceConfig, error) {
	ret := _m.Called(ctx, tx, input)

	if len(ret) == 0 {
		panic("no return value specified for CreateConfig")
	}

	var r0 *ent.ServiceConfig
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, repository.TxInterface, *service_repo.MutateConfigInput) (*ent.ServiceConfig, error)); ok {
		return rf(ctx, tx, input)
	}
	if rf, ok := ret.Get(0).(func(context.Context, repository.TxInterface, *service_repo.MutateConfigInput) *ent.ServiceConfig); ok {
		r0 = rf(ctx, tx, input)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ent.ServiceConfig)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, repository.TxInterface, *service_repo.MutateConfigInput) error); ok {
		r1 = rf(ctx, tx, input)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ServiceRepositoryMock_CreateConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateConfig'
type ServiceRepositoryMock_CreateConfig_Call struct {
	*mock.Call
}

// CreateConfig is a helper method to define mock.On call
//   - ctx context.Context
//   - tx repository.TxInterface
//   - input *service_repo.MutateConfigInput
func (_e *ServiceRepositoryMock_Expecter) CreateConfig(ctx interface{}, tx interface{}, input interface{}) *ServiceRepositoryMock_CreateConfig_Call {
	return &ServiceRepositoryMock_CreateConfig_Call{Call: _e.mock.On("CreateConfig", ctx, tx, input)}
}

func (_c *ServiceRepositoryMock_CreateConfig_Call) Run(run func(ctx context.Context, tx repository.TxInterface, input *service_repo.MutateConfigInput)) *ServiceRepositoryMock_CreateConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(repository.TxInterface), args[2].(*service_repo.MutateConfigInput))
	})
	return _c
}

func (_c *ServiceRepositoryMock_CreateConfig_Call) Return(_a0 *ent.ServiceConfig, _a1 error) *ServiceRepositoryMock_CreateConfig_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ServiceRepositoryMock_CreateConfig_Call) RunAndReturn(run func(context.Context, repository.TxInterface, *service_repo.MutateConfigInput) (*ent.ServiceConfig, error)) *ServiceRepositoryMock_CreateConfig_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function with given fields: ctx, tx, serviceID
func (_m *ServiceRepositoryMock) Delete(ctx context.Context, tx repository.TxInterface, serviceID uuid.UUID) error {
	ret := _m.Called(ctx, tx, serviceID)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, repository.TxInterface, uuid.UUID) error); ok {
		r0 = rf(ctx, tx, serviceID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ServiceRepositoryMock_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type ServiceRepositoryMock_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - tx repository.TxInterface
//   - serviceID uuid.UUID
func (_e *ServiceRepositoryMock_Expecter) Delete(ctx interface{}, tx interface{}, serviceID interface{}) *ServiceRepositoryMock_Delete_Call {
	return &ServiceRepositoryMock_Delete_Call{Call: _e.mock.On("Delete", ctx, tx, serviceID)}
}

func (_c *ServiceRepositoryMock_Delete_Call) Run(run func(ctx context.Context, tx repository.TxInterface, serviceID uuid.UUID)) *ServiceRepositoryMock_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(repository.TxInterface), args[2].(uuid.UUID))
	})
	return _c
}

func (_c *ServiceRepositoryMock_Delete_Call) Return(_a0 error) *ServiceRepositoryMock_Delete_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ServiceRepositoryMock_Delete_Call) RunAndReturn(run func(context.Context, repository.TxInterface, uuid.UUID) error) *ServiceRepositoryMock_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// GetByEnvironmentID provides a mock function with given fields: ctx, environmentID, authPredicate, withLatestDeployment
func (_m *ServiceRepositoryMock) GetByEnvironmentID(ctx context.Context, environmentID uuid.UUID, authPredicate predicate.Service, withLatestDeployment bool) ([]*ent.Service, error) {
	ret := _m.Called(ctx, environmentID, authPredicate, withLatestDeployment)

	if len(ret) == 0 {
		panic("no return value specified for GetByEnvironmentID")
	}

	var r0 []*ent.Service
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, predicate.Service, bool) ([]*ent.Service, error)); ok {
		return rf(ctx, environmentID, authPredicate, withLatestDeployment)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, predicate.Service, bool) []*ent.Service); ok {
		r0 = rf(ctx, environmentID, authPredicate, withLatestDeployment)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*ent.Service)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, predicate.Service, bool) error); ok {
		r1 = rf(ctx, environmentID, authPredicate, withLatestDeployment)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ServiceRepositoryMock_GetByEnvironmentID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByEnvironmentID'
type ServiceRepositoryMock_GetByEnvironmentID_Call struct {
	*mock.Call
}

// GetByEnvironmentID is a helper method to define mock.On call
//   - ctx context.Context
//   - environmentID uuid.UUID
//   - authPredicate predicate.Service
//   - withLatestDeployment bool
func (_e *ServiceRepositoryMock_Expecter) GetByEnvironmentID(ctx interface{}, environmentID interface{}, authPredicate interface{}, withLatestDeployment interface{}) *ServiceRepositoryMock_GetByEnvironmentID_Call {
	return &ServiceRepositoryMock_GetByEnvironmentID_Call{Call: _e.mock.On("GetByEnvironmentID", ctx, environmentID, authPredicate, withLatestDeployment)}
}

func (_c *ServiceRepositoryMock_GetByEnvironmentID_Call) Run(run func(ctx context.Context, environmentID uuid.UUID, authPredicate predicate.Service, withLatestDeployment bool)) *ServiceRepositoryMock_GetByEnvironmentID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(predicate.Service), args[3].(bool))
	})
	return _c
}

func (_c *ServiceRepositoryMock_GetByEnvironmentID_Call) Return(_a0 []*ent.Service, _a1 error) *ServiceRepositoryMock_GetByEnvironmentID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ServiceRepositoryMock_GetByEnvironmentID_Call) RunAndReturn(run func(context.Context, uuid.UUID, predicate.Service, bool) ([]*ent.Service, error)) *ServiceRepositoryMock_GetByEnvironmentID_Call {
	_c.Call.Return(run)
	return _c
}

// GetByID provides a mock function with given fields: ctx, serviceID
func (_m *ServiceRepositoryMock) GetByID(ctx context.Context, serviceID uuid.UUID) (*ent.Service, error) {
	ret := _m.Called(ctx, serviceID)

	if len(ret) == 0 {
		panic("no return value specified for GetByID")
	}

	var r0 *ent.Service
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*ent.Service, error)); ok {
		return rf(ctx, serviceID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) *ent.Service); ok {
		r0 = rf(ctx, serviceID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ent.Service)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, serviceID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ServiceRepositoryMock_GetByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByID'
type ServiceRepositoryMock_GetByID_Call struct {
	*mock.Call
}

// GetByID is a helper method to define mock.On call
//   - ctx context.Context
//   - serviceID uuid.UUID
func (_e *ServiceRepositoryMock_Expecter) GetByID(ctx interface{}, serviceID interface{}) *ServiceRepositoryMock_GetByID_Call {
	return &ServiceRepositoryMock_GetByID_Call{Call: _e.mock.On("GetByID", ctx, serviceID)}
}

func (_c *ServiceRepositoryMock_GetByID_Call) Run(run func(ctx context.Context, serviceID uuid.UUID)) *ServiceRepositoryMock_GetByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *ServiceRepositoryMock_GetByID_Call) Return(svc *ent.Service, err error) *ServiceRepositoryMock_GetByID_Call {
	_c.Call.Return(svc, err)
	return _c
}

func (_c *ServiceRepositoryMock_GetByID_Call) RunAndReturn(run func(context.Context, uuid.UUID) (*ent.Service, error)) *ServiceRepositoryMock_GetByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetByIDsAndEnvironment provides a mock function with given fields: ctx, serviceIDs, environmentID
func (_m *ServiceRepositoryMock) GetByIDsAndEnvironment(ctx context.Context, serviceIDs []uuid.UUID, environmentID uuid.UUID) ([]*ent.Service, error) {
	ret := _m.Called(ctx, serviceIDs, environmentID)

	if len(ret) == 0 {
		panic("no return value specified for GetByIDsAndEnvironment")
	}

	var r0 []*ent.Service
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []uuid.UUID, uuid.UUID) ([]*ent.Service, error)); ok {
		return rf(ctx, serviceIDs, environmentID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []uuid.UUID, uuid.UUID) []*ent.Service); ok {
		r0 = rf(ctx, serviceIDs, environmentID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*ent.Service)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []uuid.UUID, uuid.UUID) error); ok {
		r1 = rf(ctx, serviceIDs, environmentID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ServiceRepositoryMock_GetByIDsAndEnvironment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByIDsAndEnvironment'
type ServiceRepositoryMock_GetByIDsAndEnvironment_Call struct {
	*mock.Call
}

// GetByIDsAndEnvironment is a helper method to define mock.On call
//   - ctx context.Context
//   - serviceIDs []uuid.UUID
//   - environmentID uuid.UUID
func (_e *ServiceRepositoryMock_Expecter) GetByIDsAndEnvironment(ctx interface{}, serviceIDs interface{}, environmentID interface{}) *ServiceRepositoryMock_GetByIDsAndEnvironment_Call {
	return &ServiceRepositoryMock_GetByIDsAndEnvironment_Call{Call: _e.mock.On("GetByIDsAndEnvironment", ctx, serviceIDs, environmentID)}
}

func (_c *ServiceRepositoryMock_GetByIDsAndEnvironment_Call) Run(run func(ctx context.Context, serviceIDs []uuid.UUID, environmentID uuid.UUID)) *ServiceRepositoryMock_GetByIDsAndEnvironment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]uuid.UUID), args[2].(uuid.UUID))
	})
	return _c
}

func (_c *ServiceRepositoryMock_GetByIDsAndEnvironment_Call) Return(_a0 []*ent.Service, _a1 error) *ServiceRepositoryMock_GetByIDsAndEnvironment_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ServiceRepositoryMock_GetByIDsAndEnvironment_Call) RunAndReturn(run func(context.Context, []uuid.UUID, uuid.UUID) ([]*ent.Service, error)) *ServiceRepositoryMock_GetByIDsAndEnvironment_Call {
	_c.Call.Return(run)
	return _c
}

// GetByInstallationIDAndRepoName provides a mock function with given fields: ctx, installationID, repoName
func (_m *ServiceRepositoryMock) GetByInstallationIDAndRepoName(ctx context.Context, installationID int64, repoName string) ([]*ent.Service, error) {
	ret := _m.Called(ctx, installationID, repoName)

	if len(ret) == 0 {
		panic("no return value specified for GetByInstallationIDAndRepoName")
	}

	var r0 []*ent.Service
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, string) ([]*ent.Service, error)); ok {
		return rf(ctx, installationID, repoName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, string) []*ent.Service); ok {
		r0 = rf(ctx, installationID, repoName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*ent.Service)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, string) error); ok {
		r1 = rf(ctx, installationID, repoName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ServiceRepositoryMock_GetByInstallationIDAndRepoName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByInstallationIDAndRepoName'
type ServiceRepositoryMock_GetByInstallationIDAndRepoName_Call struct {
	*mock.Call
}

// GetByInstallationIDAndRepoName is a helper method to define mock.On call
//   - ctx context.Context
//   - installationID int64
//   - repoName string
func (_e *ServiceRepositoryMock_Expecter) GetByInstallationIDAndRepoName(ctx interface{}, installationID interface{}, repoName interface{}) *ServiceRepositoryMock_GetByInstallationIDAndRepoName_Call {
	return &ServiceRepositoryMock_GetByInstallationIDAndRepoName_Call{Call: _e.mock.On("GetByInstallationIDAndRepoName", ctx, installationID, repoName)}
}

func (_c *ServiceRepositoryMock_GetByInstallationIDAndRepoName_Call) Run(run func(ctx context.Context, installationID int64, repoName string)) *ServiceRepositoryMock_GetByInstallationIDAndRepoName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64), args[2].(string))
	})
	return _c
}

func (_c *ServiceRepositoryMock_GetByInstallationIDAndRepoName_Call) Return(_a0 []*ent.Service, _a1 error) *ServiceRepositoryMock_GetByInstallationIDAndRepoName_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ServiceRepositoryMock_GetByInstallationIDAndRepoName_Call) RunAndReturn(run func(context.Context, int64, string) ([]*ent.Service, error)) *ServiceRepositoryMock_GetByInstallationIDAndRepoName_Call {
	_c.Call.Return(run)
	return _c
}

// GetByName provides a mock function with given fields: ctx, name
func (_m *ServiceRepositoryMock) GetByName(ctx context.Context, name string) (*ent.Service, error) {
	ret := _m.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for GetByName")
	}

	var r0 *ent.Service
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*ent.Service, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *ent.Service); ok {
		r0 = rf(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ent.Service)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ServiceRepositoryMock_GetByName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByName'
type ServiceRepositoryMock_GetByName_Call struct {
	*mock.Call
}

// GetByName is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *ServiceRepositoryMock_Expecter) GetByName(ctx interface{}, name interface{}) *ServiceRepositoryMock_GetByName_Call {
	return &ServiceRepositoryMock_GetByName_Call{Call: _e.mock.On("GetByName", ctx, name)}
}

func (_c *ServiceRepositoryMock_GetByName_Call) Run(run func(ctx context.Context, name string)) *ServiceRepositoryMock_GetByName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *ServiceRepositoryMock_GetByName_Call) Return(_a0 *ent.Service, _a1 error) *ServiceRepositoryMock_GetByName_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ServiceRepositoryMock_GetByName_Call) RunAndReturn(run func(context.Context, string) (*ent.Service, error)) *ServiceRepositoryMock_GetByName_Call {
	_c.Call.Return(run)
	return _c
}

// GetDatabaseConfig provides a mock function with given fields: ctx, serviceID
func (_m *ServiceRepositoryMock) GetDatabaseConfig(ctx context.Context, serviceID uuid.UUID) (*schema.DatabaseConfig, error) {
	ret := _m.Called(ctx, serviceID)

	if len(ret) == 0 {
		panic("no return value specified for GetDatabaseConfig")
	}

	var r0 *schema.DatabaseConfig
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*schema.DatabaseConfig, error)); ok {
		return rf(ctx, serviceID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) *schema.DatabaseConfig); ok {
		r0 = rf(ctx, serviceID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*schema.DatabaseConfig)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, serviceID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ServiceRepositoryMock_GetDatabaseConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDatabaseConfig'
type ServiceRepositoryMock_GetDatabaseConfig_Call struct {
	*mock.Call
}

// GetDatabaseConfig is a helper method to define mock.On call
//   - ctx context.Context
//   - serviceID uuid.UUID
func (_e *ServiceRepositoryMock_Expecter) GetDatabaseConfig(ctx interface{}, serviceID interface{}) *ServiceRepositoryMock_GetDatabaseConfig_Call {
	return &ServiceRepositoryMock_GetDatabaseConfig_Call{Call: _e.mock.On("GetDatabaseConfig", ctx, serviceID)}
}

func (_c *ServiceRepositoryMock_GetDatabaseConfig_Call) Run(run func(ctx context.Context, serviceID uuid.UUID)) *ServiceRepositoryMock_GetDatabaseConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *ServiceRepositoryMock_GetDatabaseConfig_Call) Return(_a0 *schema.DatabaseConfig, _a1 error) *ServiceRepositoryMock_GetDatabaseConfig_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ServiceRepositoryMock_GetDatabaseConfig_Call) RunAndReturn(run func(context.Context, uuid.UUID) (*schema.DatabaseConfig, error)) *ServiceRepositoryMock_GetDatabaseConfig_Call {
	_c.Call.Return(run)
	return _c
}

// GetDatabaseType provides a mock function with given fields: ctx, serviceID
func (_m *ServiceRepositoryMock) GetDatabaseType(ctx context.Context, serviceID uuid.UUID) (string, error) {
	ret := _m.Called(ctx, serviceID)

	if len(ret) == 0 {
		panic("no return value specified for GetDatabaseType")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (string, error)); ok {
		return rf(ctx, serviceID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) string); ok {
		r0 = rf(ctx, serviceID)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, serviceID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ServiceRepositoryMock_GetDatabaseType_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDatabaseType'
type ServiceRepositoryMock_GetDatabaseType_Call struct {
	*mock.Call
}

// GetDatabaseType is a helper method to define mock.On call
//   - ctx context.Context
//   - serviceID uuid.UUID
func (_e *ServiceRepositoryMock_Expecter) GetDatabaseType(ctx interface{}, serviceID interface{}) *ServiceRepositoryMock_GetDatabaseType_Call {
	return &ServiceRepositoryMock_GetDatabaseType_Call{Call: _e.mock.On("GetDatabaseType", ctx, serviceID)}
}

func (_c *ServiceRepositoryMock_GetDatabaseType_Call) Run(run func(ctx context.Context, serviceID uuid.UUID)) *ServiceRepositoryMock_GetDatabaseType_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *ServiceRepositoryMock_GetDatabaseType_Call) Return(_a0 string, _a1 error) *ServiceRepositoryMock_GetDatabaseType_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ServiceRepositoryMock_GetDatabaseType_Call) RunAndReturn(run func(context.Context, uuid.UUID) (string, error)) *ServiceRepositoryMock_GetDatabaseType_Call {
	_c.Call.Return(run)
	return _c
}

// GetDatabases provides a mock function with given fields: ctx
func (_m *ServiceRepositoryMock) GetDatabases(ctx context.Context) ([]*ent.Service, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetDatabases")
	}

	var r0 []*ent.Service
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]*ent.Service, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []*ent.Service); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*ent.Service)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ServiceRepositoryMock_GetDatabases_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDatabases'
type ServiceRepositoryMock_GetDatabases_Call struct {
	*mock.Call
}

// GetDatabases is a helper method to define mock.On call
//   - ctx context.Context
func (_e *ServiceRepositoryMock_Expecter) GetDatabases(ctx interface{}) *ServiceRepositoryMock_GetDatabases_Call {
	return &ServiceRepositoryMock_GetDatabases_Call{Call: _e.mock.On("GetDatabases", ctx)}
}

func (_c *ServiceRepositoryMock_GetDatabases_Call) Run(run func(ctx context.Context)) *ServiceRepositoryMock_GetDatabases_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *ServiceRepositoryMock_GetDatabases_Call) Return(_a0 []*ent.Service, _a1 error) *ServiceRepositoryMock_GetDatabases_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ServiceRepositoryMock_GetDatabases_Call) RunAndReturn(run func(context.Context) ([]*ent.Service, error)) *ServiceRepositoryMock_GetDatabases_Call {
	_c.Call.Return(run)
	return _c
}

// GetDeploymentNamespace provides a mock function with given fields: ctx, serviceID
func (_m *ServiceRepositoryMock) GetDeploymentNamespace(ctx context.Context, serviceID uuid.UUID) (string, error) {
	ret := _m.Called(ctx, serviceID)

	if len(ret) == 0 {
		panic("no return value specified for GetDeploymentNamespace")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (string, error)); ok {
		return rf(ctx, serviceID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) string); ok {
		r0 = rf(ctx, serviceID)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, serviceID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ServiceRepositoryMock_GetDeploymentNamespace_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDeploymentNamespace'
type ServiceRepositoryMock_GetDeploymentNamespace_Call struct {
	*mock.Call
}

// GetDeploymentNamespace is a helper method to define mock.On call
//   - ctx context.Context
//   - serviceID uuid.UUID
func (_e *ServiceRepositoryMock_Expecter) GetDeploymentNamespace(ctx interface{}, serviceID interface{}) *ServiceRepositoryMock_GetDeploymentNamespace_Call {
	return &ServiceRepositoryMock_GetDeploymentNamespace_Call{Call: _e.mock.On("GetDeploymentNamespace", ctx, serviceID)}
}

func (_c *ServiceRepositoryMock_GetDeploymentNamespace_Call) Run(run func(ctx context.Context, serviceID uuid.UUID)) *ServiceRepositoryMock_GetDeploymentNamespace_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *ServiceRepositoryMock_GetDeploymentNamespace_Call) Return(_a0 string, _a1 error) *ServiceRepositoryMock_GetDeploymentNamespace_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ServiceRepositoryMock_GetDeploymentNamespace_Call) RunAndReturn(run func(context.Context, uuid.UUID) (string, error)) *ServiceRepositoryMock_GetDeploymentNamespace_Call {
	_c.Call.Return(run)
	return _c
}

// GetGithubPrivateKey provides a mock function with given fields: ctx, serviceID
func (_m *ServiceRepositoryMock) GetGithubPrivateKey(ctx context.Context, serviceID uuid.UUID) (string, error) {
	ret := _m.Called(ctx, serviceID)

	if len(ret) == 0 {
		panic("no return value specified for GetGithubPrivateKey")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (string, error)); ok {
		return rf(ctx, serviceID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) string); ok {
		r0 = rf(ctx, serviceID)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, serviceID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ServiceRepositoryMock_GetGithubPrivateKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetGithubPrivateKey'
type ServiceRepositoryMock_GetGithubPrivateKey_Call struct {
	*mock.Call
}

// GetGithubPrivateKey is a helper method to define mock.On call
//   - ctx context.Context
//   - serviceID uuid.UUID
func (_e *ServiceRepositoryMock_Expecter) GetGithubPrivateKey(ctx interface{}, serviceID interface{}) *ServiceRepositoryMock_GetGithubPrivateKey_Call {
	return &ServiceRepositoryMock_GetGithubPrivateKey_Call{Call: _e.mock.On("GetGithubPrivateKey", ctx, serviceID)}
}

func (_c *ServiceRepositoryMock_GetGithubPrivateKey_Call) Run(run func(ctx context.Context, serviceID uuid.UUID)) *ServiceRepositoryMock_GetGithubPrivateKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *ServiceRepositoryMock_GetGithubPrivateKey_Call) Return(_a0 string, _a1 error) *ServiceRepositoryMock_GetGithubPrivateKey_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ServiceRepositoryMock_GetGithubPrivateKey_Call) RunAndReturn(run func(context.Context, uuid.UUID) (string, error)) *ServiceRepositoryMock_GetGithubPrivateKey_Call {
	_c.Call.Return(run)
	return _c
}

// GetPVCMountPaths provides a mock function with given fields: ctx, pvcs
func (_m *ServiceRepositoryMock) GetPVCMountPaths(ctx context.Context, pvcs []*models.PVCInfo) (map[string]string, error) {
	ret := _m.Called(ctx, pvcs)

	if len(ret) == 0 {
		panic("no return value specified for GetPVCMountPaths")
	}

	var r0 map[string]string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []*models.PVCInfo) (map[string]string, error)); ok {
		return rf(ctx, pvcs)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []*models.PVCInfo) map[string]string); ok {
		r0 = rf(ctx, pvcs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]string)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []*models.PVCInfo) error); ok {
		r1 = rf(ctx, pvcs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ServiceRepositoryMock_GetPVCMountPaths_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPVCMountPaths'
type ServiceRepositoryMock_GetPVCMountPaths_Call struct {
	*mock.Call
}

// GetPVCMountPaths is a helper method to define mock.On call
//   - ctx context.Context
//   - pvcs []*models.PVCInfo
func (_e *ServiceRepositoryMock_Expecter) GetPVCMountPaths(ctx interface{}, pvcs interface{}) *ServiceRepositoryMock_GetPVCMountPaths_Call {
	return &ServiceRepositoryMock_GetPVCMountPaths_Call{Call: _e.mock.On("GetPVCMountPaths", ctx, pvcs)}
}

func (_c *ServiceRepositoryMock_GetPVCMountPaths_Call) Run(run func(ctx context.Context, pvcs []*models.PVCInfo)) *ServiceRepositoryMock_GetPVCMountPaths_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]*models.PVCInfo))
	})
	return _c
}

func (_c *ServiceRepositoryMock_GetPVCMountPaths_Call) Return(_a0 map[string]string, _a1 error) *ServiceRepositoryMock_GetPVCMountPaths_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ServiceRepositoryMock_GetPVCMountPaths_Call) RunAndReturn(run func(context.Context, []*models.PVCInfo) (map[string]string, error)) *ServiceRepositoryMock_GetPVCMountPaths_Call {
	_c.Call.Return(run)
	return _c
}

// GetServicesUsingPVC provides a mock function with given fields: ctx, pvcID
func (_m *ServiceRepositoryMock) GetServicesUsingPVC(ctx context.Context, pvcID string) ([]*ent.Service, error) {
	ret := _m.Called(ctx, pvcID)

	if len(ret) == 0 {
		panic("no return value specified for GetServicesUsingPVC")
	}

	var r0 []*ent.Service
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]*ent.Service, error)); ok {
		return rf(ctx, pvcID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []*ent.Service); ok {
		r0 = rf(ctx, pvcID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*ent.Service)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, pvcID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ServiceRepositoryMock_GetServicesUsingPVC_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetServicesUsingPVC'
type ServiceRepositoryMock_GetServicesUsingPVC_Call struct {
	*mock.Call
}

// GetServicesUsingPVC is a helper method to define mock.On call
//   - ctx context.Context
//   - pvcID string
func (_e *ServiceRepositoryMock_Expecter) GetServicesUsingPVC(ctx interface{}, pvcID interface{}) *ServiceRepositoryMock_GetServicesUsingPVC_Call {
	return &ServiceRepositoryMock_GetServicesUsingPVC_Call{Call: _e.mock.On("GetServicesUsingPVC", ctx, pvcID)}
}

func (_c *ServiceRepositoryMock_GetServicesUsingPVC_Call) Run(run func(ctx context.Context, pvcID string)) *ServiceRepositoryMock_GetServicesUsingPVC_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *ServiceRepositoryMock_GetServicesUsingPVC_Call) Return(_a0 []*ent.Service, _a1 error) *ServiceRepositoryMock_GetServicesUsingPVC_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ServiceRepositoryMock_GetServicesUsingPVC_Call) RunAndReturn(run func(context.Context, string) ([]*ent.Service, error)) *ServiceRepositoryMock_GetServicesUsingPVC_Call {
	_c.Call.Return(run)
	return _c
}

// IsVolumeInUse provides a mock function with given fields: ctx, volumeName
func (_m *ServiceRepositoryMock) IsVolumeInUse(ctx context.Context, volumeName string) (bool, error) {
	ret := _m.Called(ctx, volumeName)

	if len(ret) == 0 {
		panic("no return value specified for IsVolumeInUse")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (bool, error)); ok {
		return rf(ctx, volumeName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) bool); ok {
		r0 = rf(ctx, volumeName)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, volumeName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ServiceRepositoryMock_IsVolumeInUse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsVolumeInUse'
type ServiceRepositoryMock_IsVolumeInUse_Call struct {
	*mock.Call
}

// IsVolumeInUse is a helper method to define mock.On call
//   - ctx context.Context
//   - volumeName string
func (_e *ServiceRepositoryMock_Expecter) IsVolumeInUse(ctx interface{}, volumeName interface{}) *ServiceRepositoryMock_IsVolumeInUse_Call {
	return &ServiceRepositoryMock_IsVolumeInUse_Call{Call: _e.mock.On("IsVolumeInUse", ctx, volumeName)}
}

func (_c *ServiceRepositoryMock_IsVolumeInUse_Call) Run(run func(ctx context.Context, volumeName string)) *ServiceRepositoryMock_IsVolumeInUse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *ServiceRepositoryMock_IsVolumeInUse_Call) Return(_a0 bool, _a1 error) *ServiceRepositoryMock_IsVolumeInUse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ServiceRepositoryMock_IsVolumeInUse_Call) RunAndReturn(run func(context.Context, string) (bool, error)) *ServiceRepositoryMock_IsVolumeInUse_Call {
	_c.Call.Return(run)
	return _c
}

// NeedsDeployment provides a mock function with given fields: ctx, service
func (_m *ServiceRepositoryMock) NeedsDeployment(ctx context.Context, service *ent.Service) (service_repo.NeedsDeploymentResponse, error) {
	ret := _m.Called(ctx, service)

	if len(ret) == 0 {
		panic("no return value specified for NeedsDeployment")
	}

	var r0 service_repo.NeedsDeploymentResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ent.Service) (service_repo.NeedsDeploymentResponse, error)); ok {
		return rf(ctx, service)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ent.Service) service_repo.NeedsDeploymentResponse); ok {
		r0 = rf(ctx, service)
	} else {
		r0 = ret.Get(0).(service_repo.NeedsDeploymentResponse)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ent.Service) error); ok {
		r1 = rf(ctx, service)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ServiceRepositoryMock_NeedsDeployment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NeedsDeployment'
type ServiceRepositoryMock_NeedsDeployment_Call struct {
	*mock.Call
}

// NeedsDeployment is a helper method to define mock.On call
//   - ctx context.Context
//   - service *ent.Service
func (_e *ServiceRepositoryMock_Expecter) NeedsDeployment(ctx interface{}, service interface{}) *ServiceRepositoryMock_NeedsDeployment_Call {
	return &ServiceRepositoryMock_NeedsDeployment_Call{Call: _e.mock.On("NeedsDeployment", ctx, service)}
}

func (_c *ServiceRepositoryMock_NeedsDeployment_Call) Run(run func(ctx context.Context, service *ent.Service)) *ServiceRepositoryMock_NeedsDeployment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*ent.Service))
	})
	return _c
}

func (_c *ServiceRepositoryMock_NeedsDeployment_Call) Return(_a0 service_repo.NeedsDeploymentResponse, _a1 error) *ServiceRepositoryMock_NeedsDeployment_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ServiceRepositoryMock_NeedsDeployment_Call) RunAndReturn(run func(context.Context, *ent.Service) (service_repo.NeedsDeploymentResponse, error)) *ServiceRepositoryMock_NeedsDeployment_Call {
	_c.Call.Return(run)
	return _c
}

// SetCurrentDeployment provides a mock function with given fields: ctx, tx, serviceID, deploymentID
func (_m *ServiceRepositoryMock) SetCurrentDeployment(ctx context.Context, tx repository.TxInterface, serviceID uuid.UUID, deploymentID uuid.UUID) error {
	ret := _m.Called(ctx, tx, serviceID, deploymentID)

	if len(ret) == 0 {
		panic("no return value specified for SetCurrentDeployment")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, repository.TxInterface, uuid.UUID, uuid.UUID) error); ok {
		r0 = rf(ctx, tx, serviceID, deploymentID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ServiceRepositoryMock_SetCurrentDeployment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetCurrentDeployment'
type ServiceRepositoryMock_SetCurrentDeployment_Call struct {
	*mock.Call
}

// SetCurrentDeployment is a helper method to define mock.On call
//   - ctx context.Context
//   - tx repository.TxInterface
//   - serviceID uuid.UUID
//   - deploymentID uuid.UUID
func (_e *ServiceRepositoryMock_Expecter) SetCurrentDeployment(ctx interface{}, tx interface{}, serviceID interface{}, deploymentID interface{}) *ServiceRepositoryMock_SetCurrentDeployment_Call {
	return &ServiceRepositoryMock_SetCurrentDeployment_Call{Call: _e.mock.On("SetCurrentDeployment", ctx, tx, serviceID, deploymentID)}
}

func (_c *ServiceRepositoryMock_SetCurrentDeployment_Call) Run(run func(ctx context.Context, tx repository.TxInterface, serviceID uuid.UUID, deploymentID uuid.UUID)) *ServiceRepositoryMock_SetCurrentDeployment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(repository.TxInterface), args[2].(uuid.UUID), args[3].(uuid.UUID))
	})
	return _c
}

func (_c *ServiceRepositoryMock_SetCurrentDeployment_Call) Return(_a0 error) *ServiceRepositoryMock_SetCurrentDeployment_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ServiceRepositoryMock_SetCurrentDeployment_Call) RunAndReturn(run func(context.Context, repository.TxInterface, uuid.UUID, uuid.UUID) error) *ServiceRepositoryMock_SetCurrentDeployment_Call {
	_c.Call.Return(run)
	return _c
}

// SummarizeServices provides a mock function with given fields: ctx, environmentIDs
func (_m *ServiceRepositoryMock) SummarizeServices(ctx context.Context, environmentIDs []uuid.UUID) (map[uuid.UUID]int, map[uuid.UUID][]string, error) {
	ret := _m.Called(ctx, environmentIDs)

	if len(ret) == 0 {
		panic("no return value specified for SummarizeServices")
	}

	var r0 map[uuid.UUID]int
	var r1 map[uuid.UUID][]string
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, []uuid.UUID) (map[uuid.UUID]int, map[uuid.UUID][]string, error)); ok {
		return rf(ctx, environmentIDs)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []uuid.UUID) map[uuid.UUID]int); ok {
		r0 = rf(ctx, environmentIDs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[uuid.UUID]int)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []uuid.UUID) map[uuid.UUID][]string); ok {
		r1 = rf(ctx, environmentIDs)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(map[uuid.UUID][]string)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, []uuid.UUID) error); ok {
		r2 = rf(ctx, environmentIDs)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ServiceRepositoryMock_SummarizeServices_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SummarizeServices'
type ServiceRepositoryMock_SummarizeServices_Call struct {
	*mock.Call
}

// SummarizeServices is a helper method to define mock.On call
//   - ctx context.Context
//   - environmentIDs []uuid.UUID
func (_e *ServiceRepositoryMock_Expecter) SummarizeServices(ctx interface{}, environmentIDs interface{}) *ServiceRepositoryMock_SummarizeServices_Call {
	return &ServiceRepositoryMock_SummarizeServices_Call{Call: _e.mock.On("SummarizeServices", ctx, environmentIDs)}
}

func (_c *ServiceRepositoryMock_SummarizeServices_Call) Run(run func(ctx context.Context, environmentIDs []uuid.UUID)) *ServiceRepositoryMock_SummarizeServices_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]uuid.UUID))
	})
	return _c
}

func (_c *ServiceRepositoryMock_SummarizeServices_Call) Return(counts map[uuid.UUID]int, icons map[uuid.UUID][]string, err error) *ServiceRepositoryMock_SummarizeServices_Call {
	_c.Call.Return(counts, icons, err)
	return _c
}

func (_c *ServiceRepositoryMock_SummarizeServices_Call) RunAndReturn(run func(context.Context, []uuid.UUID) (map[uuid.UUID]int, map[uuid.UUID][]string, error)) *ServiceRepositoryMock_SummarizeServices_Call {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function with given fields: ctx, tx, serviceID, name, description
func (_m *ServiceRepositoryMock) Update(ctx context.Context, tx repository.TxInterface, serviceID uuid.UUID, name *string, description *string) error {
	ret := _m.Called(ctx, tx, serviceID, name, description)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, repository.TxInterface, uuid.UUID, *string, *string) error); ok {
		r0 = rf(ctx, tx, serviceID, name, description)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ServiceRepositoryMock_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type ServiceRepositoryMock_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - ctx context.Context
//   - tx repository.TxInterface
//   - serviceID uuid.UUID
//   - name *string
//   - description *string
func (_e *ServiceRepositoryMock_Expecter) Update(ctx interface{}, tx interface{}, serviceID interface{}, name interface{}, description interface{}) *ServiceRepositoryMock_Update_Call {
	return &ServiceRepositoryMock_Update_Call{Call: _e.mock.On("Update", ctx, tx, serviceID, name, description)}
}

func (_c *ServiceRepositoryMock_Update_Call) Run(run func(ctx context.Context, tx repository.TxInterface, serviceID uuid.UUID, name *string, description *string)) *ServiceRepositoryMock_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(repository.TxInterface), args[2].(uuid.UUID), args[3].(*string), args[4].(*string))
	})
	return _c
}

func (_c *ServiceRepositoryMock_Update_Call) Return(_a0 error) *ServiceRepositoryMock_Update_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ServiceRepositoryMock_Update_Call) RunAndReturn(run func(context.Context, repository.TxInterface, uuid.UUID, *string, *string) error) *ServiceRepositoryMock_Update_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateConfig provides a mock function with given fields: ctx, tx, input
func (_m *ServiceRepositoryMock) UpdateConfig(ctx context.Context, tx repository.TxInterface, input *service_repo.MutateConfigInput) error {
	ret := _m.Called(ctx, tx, input)

	if len(ret) == 0 {
		panic("no return value specified for UpdateConfig")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, repository.TxInterface, *service_repo.MutateConfigInput) error); ok {
		r0 = rf(ctx, tx, input)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ServiceRepositoryMock_UpdateConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateConfig'
type ServiceRepositoryMock_UpdateConfig_Call struct {
	*mock.Call
}

// UpdateConfig is a helper method to define mock.On call
//   - ctx context.Context
//   - tx repository.TxInterface
//   - input *service_repo.MutateConfigInput
func (_e *ServiceRepositoryMock_Expecter) UpdateConfig(ctx interface{}, tx interface{}, input interface{}) *ServiceRepositoryMock_UpdateConfig_Call {
	return &ServiceRepositoryMock_UpdateConfig_Call{Call: _e.mock.On("UpdateConfig", ctx, tx, input)}
}

func (_c *ServiceRepositoryMock_UpdateConfig_Call) Run(run func(ctx context.Context, tx repository.TxInterface, input *service_repo.MutateConfigInput)) *ServiceRepositoryMock_UpdateConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(repository.TxInterface), args[2].(*service_repo.MutateConfigInput))
	})
	return _c
}

func (_c *ServiceRepositoryMock_UpdateConfig_Call) Return(_a0 error) *ServiceRepositoryMock_UpdateConfig_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ServiceRepositoryMock_UpdateConfig_Call) RunAndReturn(run func(context.Context, repository.TxInterface, *service_repo.MutateConfigInput) error) *ServiceRepositoryMock_UpdateConfig_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateDatabaseStorageSize provides a mock function with given fields: ctx, tx, serviceID, newSize
func (_m *ServiceRepositoryMock) UpdateDatabaseStorageSize(ctx context.Context, tx repository.TxInterface, serviceID uuid.UUID, newSize string) (*schema.DatabaseConfig, error) {
	ret := _m.Called(ctx, tx, serviceID, newSize)

	if len(ret) == 0 {
		panic("no return value specified for UpdateDatabaseStorageSize")
	}

	var r0 *schema.DatabaseConfig
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, repository.TxInterface, uuid.UUID, string) (*schema.DatabaseConfig, error)); ok {
		return rf(ctx, tx, serviceID, newSize)
	}
	if rf, ok := ret.Get(0).(func(context.Context, repository.TxInterface, uuid.UUID, string) *schema.DatabaseConfig); ok {
		r0 = rf(ctx, tx, serviceID, newSize)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*schema.DatabaseConfig)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, repository.TxInterface, uuid.UUID, string) error); ok {
		r1 = rf(ctx, tx, serviceID, newSize)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ServiceRepositoryMock_UpdateDatabaseStorageSize_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateDatabaseStorageSize'
type ServiceRepositoryMock_UpdateDatabaseStorageSize_Call struct {
	*mock.Call
}

// UpdateDatabaseStorageSize is a helper method to define mock.On call
//   - ctx context.Context
//   - tx repository.TxInterface
//   - serviceID uuid.UUID
//   - newSize string
func (_e *ServiceRepositoryMock_Expecter) UpdateDatabaseStorageSize(ctx interface{}, tx interface{}, serviceID interface{}, newSize interface{}) *ServiceRepositoryMock_UpdateDatabaseStorageSize_Call {
	return &ServiceRepositoryMock_UpdateDatabaseStorageSize_Call{Call: _e.mock.On("UpdateDatabaseStorageSize", ctx, tx, serviceID, newSize)}
}

func (_c *ServiceRepositoryMock_UpdateDatabaseStorageSize_Call) Run(run func(ctx context.Context, tx repository.TxInterface, serviceID uuid.UUID, newSize string)) *ServiceRepositoryMock_UpdateDatabaseStorageSize_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(repository.TxInterface), args[2].(uuid.UUID), args[3].(string))
	})
	return _c
}

func (_c *ServiceRepositoryMock_UpdateDatabaseStorageSize_Call) Return(_a0 *schema.DatabaseConfig, _a1 error) *ServiceRepositoryMock_UpdateDatabaseStorageSize_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ServiceRepositoryMock_UpdateDatabaseStorageSize_Call) RunAndReturn(run func(context.Context, repository.TxInterface, uuid.UUID, string) (*schema.DatabaseConfig, error)) *ServiceRepositoryMock_UpdateDatabaseStorageSize_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateVariableMounts provides a mock function with given fields: ctx, tx, serviceID, variableMounts
func (_m *ServiceRepositoryMock) UpdateVariableMounts(ctx context.Context, tx repository.TxInterface, serviceID uuid.UUID, variableMounts []*schema.VariableMount) error {
	ret := _m.Called(ctx, tx, serviceID, variableMounts)

	if len(ret) == 0 {
		panic("no return value specified for UpdateVariableMounts")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, repository.TxInterface, uuid.UUID, []*schema.VariableMount) error); ok {
		r0 = rf(ctx, tx, serviceID, variableMounts)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ServiceRepositoryMock_UpdateVariableMounts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateVariableMounts'
type ServiceRepositoryMock_UpdateVariableMounts_Call struct {
	*mock.Call
}

// UpdateVariableMounts is a helper method to define mock.On call
//   - ctx context.Context
//   - tx repository.TxInterface
//   - serviceID uuid.UUID
//   - variableMounts []*schema.VariableMount
func (_e *ServiceRepositoryMock_Expecter) UpdateVariableMounts(ctx interface{}, tx interface{}, serviceID interface{}, variableMounts interface{}) *ServiceRepositoryMock_UpdateVariableMounts_Call {
	return &ServiceRepositoryMock_UpdateVariableMounts_Call{Call: _e.mock.On("UpdateVariableMounts", ctx, tx, serviceID, variableMounts)}
}

func (_c *ServiceRepositoryMock_UpdateVariableMounts_Call) Run(run func(ctx context.Context, tx repository.TxInterface, serviceID uuid.UUID, variableMounts []*schema.VariableMount)) *ServiceRepositoryMock_UpdateVariableMounts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(repository.TxInterface), args[2].(uuid.UUID), args[3].([]*schema.VariableMount))
	})
	return _c
}

func (_c *ServiceRepositoryMock_UpdateVariableMounts_Call) Return(_a0 error) *ServiceRepositoryMock_UpdateVariableMounts_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ServiceRepositoryMock_UpdateVariableMounts_Call) RunAndReturn(run func(context.Context, repository.TxInterface, uuid.UUID, []*schema.VariableMount) error) *ServiceRepositoryMock_UpdateVariableMounts_Call {
	_c.Call.Return(run)
	return _c
}

// NewServiceRepositoryMock creates a new instance of ServiceRepositoryMock. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewServiceRepositoryMock(t interface {
	mock.TestingT
	Cleanup(func())
}) *ServiceRepositoryMock {
	mock := &ServiceRepositoryMock{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
