// Code generated by mockery v2.53.4. DO NOT EDIT.

package mocks_repository_permissions

import (
	context "context"

	mock "github.com/stretchr/testify/mock"
	ent "github.com/unbindapp/unbind-api/ent"

	permissions_repo "github.com/unbindapp/unbind-api/internal/repositories/permissions"

	predicate "github.com/unbindapp/unbind-api/ent/predicate"

	schema "github.com/unbindapp/unbind-api/ent/schema"

	uuid "github.com/google/uuid"
)

// PermissionsRepositoryMock is an autogenerated mock type for the PermissionsRepositoryInterface type
type PermissionsRepositoryMock struct {
	mock.Mock
}

type PermissionsRepositoryMock_Expecter struct {
	mock *mock.Mock
}

func (_m *PermissionsRepositoryMock) EXPECT() *PermissionsRepositoryMock_Expecter {
	return &PermissionsRepositoryMock_Expecter{mock: &_m.Mock}
}

// AddToGroup provides a mock function with given fields: ctx, groupID, permissionID
func (_m *PermissionsRepositoryMock) AddToGroup(ctx context.Context, groupID uuid.UUID, permissionID uuid.UUID) error {
	ret := _m.Called(ctx, groupID, permissionID)

	if len(ret) == 0 {
		panic("no return value specified for AddToGroup")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID) error); ok {
		r0 = rf(ctx, groupID, permissionID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// PermissionsRepositoryMock_AddToGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddToGroup'
type PermissionsRepositoryMock_AddToGroup_Call struct {
	*mock.Call
}

// AddToGroup is a helper method to define mock.On call
//   - ctx context.Context
//   - groupID uuid.UUID
//   - permissionID uuid.UUID
func (_e *PermissionsRepositoryMock_Expecter) AddToGroup(ctx interface{}, groupID interface{}, permissionID interface{}) *PermissionsRepositoryMock_AddToGroup_Call {
	return &PermissionsRepositoryMock_AddToGroup_Call{Call: _e.mock.On("AddToGroup", ctx, groupID, permissionID)}
}

func (_c *PermissionsRepositoryMock_AddToGroup_Call) Run(run func(ctx context.Context, groupID uuid.UUID, permissionID uuid.UUID)) *PermissionsRepositoryMock_AddToGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID))
	})
	return _c
}

func (_c *PermissionsRepositoryMock_AddToGroup_Call) Return(_a0 error) *PermissionsRepositoryMock_AddToGroup_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *PermissionsRepositoryMock_AddToGroup_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID) error) *PermissionsRepositoryMock_AddToGroup_Call {
	_c.Call.Return(run)
	return _c
}

// Check provides a mock function with given fields: ctx, userID, checks
func (_m *PermissionsRepositoryMock) Check(ctx context.Context, userID uuid.UUID, checks []permissions_repo.PermissionCheck) error {
	ret := _m.Called(ctx, userID, checks)

	if len(ret) == 0 {
		panic("no return value specified for Check")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, []permissions_repo.PermissionCheck) error); ok {
		r0 = rf(ctx, userID, checks)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// PermissionsRepositoryMock_Check_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Check'
type PermissionsRepositoryMock_Check_Call struct {
	*mock.Call
}

// Check is a helper method to define mock.On call
//   - ctx context.Context
//   - userID uuid.UUID
//   - checks []permissions_repo.PermissionCheck
func (_e *PermissionsRepositoryMock_Expecter) Check(ctx interface{}, userID interface{}, checks interface{}) *PermissionsRepositoryMock_Check_Call {
	return &PermissionsRepositoryMock_Check_Call{Call: _e.mock.On("Check", ctx, userID, checks)}
}

func (_c *PermissionsRepositoryMock_Check_Call) Run(run func(ctx context.Context, userID uuid.UUID, checks []permissions_repo.PermissionCheck)) *PermissionsRepositoryMock_Check_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].([]permissions_repo.PermissionCheck))
	})
	return _c
}

func (_c *PermissionsRepositoryMock_Check_Call) Return(_a0 error) *PermissionsRepositoryMock_Check_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *PermissionsRepositoryMock_Check_Call) RunAndReturn(run func(context.Context, uuid.UUID, []permissions_repo.PermissionCheck) error) *PermissionsRepositoryMock_Check_Call {
	_c.Call.Return(run)
	return _c
}

// Create provides a mock function with given fields: ctx, action, resourceType, selector
func (_m *PermissionsRepositoryMock) Create(ctx context.Context, action schema.PermittedAction, resourceType schema.ResourceType, selector schema.ResourceSelector) (*ent.Permission, error) {
	ret := _m.Called(ctx, action, resourceType, selector)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 *ent.Permission
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, schema.PermittedAction, schema.ResourceType, schema.ResourceSelector) (*ent.Permission, error)); ok {
		return rf(ctx, action, resourceType, selector)
	}
	if rf, ok := ret.Get(0).(func(context.Context, schema.PermittedAction, schema.ResourceType, schema.ResourceSelector) *ent.Permission); ok {
		r0 = rf(ctx, action, resourceType, selector)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ent.Permission)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, schema.PermittedAction, schema.ResourceType, schema.ResourceSelector) error); ok {
		r1 = rf(ctx, action, resourceType, selector)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PermissionsRepositoryMock_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type PermissionsRepositoryMock_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - action schema.PermittedAction
//   - resourceType schema.ResourceType
//   - selector schema.ResourceSelector
func (_e *PermissionsRepositoryMock_Expecter) Create(ctx interface{}, action interface{}, resourceType interface{}, selector interface{}) *PermissionsRepositoryMock_Create_Call {
	return &PermissionsRepositoryMock_Create_Call{Call: _e.mock.On("Create", ctx, action, resourceType, selector)}
}

func (_c *PermissionsRepositoryMock_Create_Call) Run(run func(ctx context.Context, action schema.PermittedAction, resourceType schema.ResourceType, selector schema.ResourceSelector)) *PermissionsRepositoryMock_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(schema.PermittedAction), args[2].(schema.ResourceType), args[3].(schema.ResourceSelector))
	})
	return _c
}

func (_c *PermissionsRepositoryMock_Create_Call) Return(_a0 *ent.Permission, _a1 error) *PermissionsRepositoryMock_Create_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *PermissionsRepositoryMock_Create_Call) RunAndReturn(run func(context.Context, schema.PermittedAction, schema.ResourceType, schema.ResourceSelector) (*ent.Permission, error)) *PermissionsRepositoryMock_Create_Call {
	_c.Call.Return(run)
	return _c
}

// CreatePermission provides a mock function with given fields: ctx, groupID, action, resourceType, selector
func (_m *PermissionsRepositoryMock) CreatePermission(ctx context.Context, groupID uuid.UUID, action schema.PermittedAction, resourceType schema.ResourceType, selector schema.ResourceSelector) (*ent.Permission, error) {
	ret := _m.Called(ctx, groupID, action, resourceType, selector)

	if len(ret) == 0 {
		panic("no return value specified for CreatePermission")
	}

	var r0 *ent.Permission
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, schema.PermittedAction, schema.ResourceType, schema.ResourceSelector) (*ent.Permission, error)); ok {
		return rf(ctx, groupID, action, resourceType, selector)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, schema.PermittedAction, schema.ResourceType, schema.ResourceSelector) *ent.Permission); ok {
		r0 = rf(ctx, groupID, action, resourceType, selector)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ent.Permission)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, schema.PermittedAction, schema.ResourceType, schema.ResourceSelector) error); ok {
		r1 = rf(ctx, groupID, action, resourceType, selector)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PermissionsRepositoryMock_CreatePermission_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreatePermission'
type PermissionsRepositoryMock_CreatePermission_Call struct {
	*mock.Call
}

// CreatePermission is a helper method to define mock.On call
//   - ctx context.Context
//   - groupID uuid.UUID
//   - action schema.PermittedAction
//   - resourceType schema.ResourceType
//   - selector schema.ResourceSelector
func (_e *PermissionsRepositoryMock_Expecter) CreatePermission(ctx interface{}, groupID interface{}, action interface{}, resourceType interface{}, selector interface{}) *PermissionsRepositoryMock_CreatePermission_Call {
	return &PermissionsRepositoryMock_CreatePermission_Call{Call: _e.mock.On("CreatePermission", ctx, groupID, action, resourceType, selector)}
}

func (_c *PermissionsRepositoryMock_CreatePermission_Call) Run(run func(ctx context.Context, groupID uuid.UUID, action schema.PermittedAction, resourceType schema.ResourceType, selector schema.ResourceSelector)) *PermissionsRepositoryMock_CreatePermission_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(schema.PermittedAction), args[3].(schema.ResourceType), args[4].(schema.ResourceSelector))
	})
	return _c
}

func (_c *PermissionsRepositoryMock_CreatePermission_Call) Return(_a0 *ent.Permission, _a1 error) *PermissionsRepositoryMock_CreatePermission_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *PermissionsRepositoryMock_CreatePermission_Call) RunAndReturn(run func(context.Context, uuid.UUID, schema.PermittedAction, schema.ResourceType, schema.ResourceSelector) (*ent.Permission, error)) *PermissionsRepositoryMock_CreatePermission_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function with given fields: ctx, id
func (_m *PermissionsRepositoryMock) Delete(ctx context.Context, id uuid.UUID) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// PermissionsRepositoryMock_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type PermissionsRepositoryMock_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
func (_e *PermissionsRepositoryMock_Expecter) Delete(ctx interface{}, id interface{}) *PermissionsRepositoryMock_Delete_Call {
	return &PermissionsRepositoryMock_Delete_Call{Call: _e.mock.On("Delete", ctx, id)}
}

func (_c *PermissionsRepositoryMock_Delete_Call) Run(run func(ctx context.Context, id uuid.UUID)) *PermissionsRepositoryMock_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *PermissionsRepositoryMock_Delete_Call) Return(_a0 error) *PermissionsRepositoryMock_Delete_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *PermissionsRepositoryMock_Delete_Call) RunAndReturn(run func(context.Context, uuid.UUID) error) *PermissionsRepositoryMock_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// DeletePermission provides a mock function with given fields: ctx, permissionID
func (_m *PermissionsRepositoryMock) DeletePermission(ctx context.Context, permissionID uuid.UUID) error {
	ret := _m.Called(ctx, permissionID)

	if len(ret) == 0 {
		panic("no return value specified for DeletePermission")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = rf(ctx, permissionID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// PermissionsRepositoryMock_DeletePermission_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeletePermission'
type PermissionsRepositoryMock_DeletePermission_Call struct {
	*mock.Call
}

// DeletePermission is a helper method to define mock.On call
//   - ctx context.Context
//   - permissionID uuid.UUID
func (_e *PermissionsRepositoryMock_Expecter) DeletePermission(ctx interface{}, permissionID interface{}) *PermissionsRepositoryMock_DeletePermission_Call {
	return &PermissionsRepositoryMock_DeletePermission_Call{Call: _e.mock.On("DeletePermission", ctx, permissionID)}
}

func (_c *PermissionsRepositoryMock_DeletePermission_Call) Run(run func(ctx context.Context, permissionID uuid.UUID)) *PermissionsRepositoryMock_DeletePermission_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *PermissionsRepositoryMock_DeletePermission_Call) Return(_a0 error) *PermissionsRepositoryMock_DeletePermission_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *PermissionsRepositoryMock_DeletePermission_Call) RunAndReturn(run func(context.Context, uuid.UUID) error) *PermissionsRepositoryMock_DeletePermission_Call {
	_c.Call.Return(run)
	return _c
}

// GetAccessibleEnvironmentPredicates provides a mock function with given fields: ctx, userID, action, projectID
func (_m *PermissionsRepositoryMock) GetAccessibleEnvironmentPredicates(ctx context.Context, userID uuid.UUID, action schema.PermittedAction, projectID *uuid.UUID) (predicate.Environment, error) {
	ret := _m.Called(ctx, userID, action, projectID)

	if len(ret) == 0 {
		panic("no return value specified for GetAccessibleEnvironmentPredicates")
	}

	var r0 predicate.Environment
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, schema.PermittedAction, *uuid.UUID) (predicate.Environment, error)); ok {
		return rf(ctx, userID, action, projectID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, schema.PermittedAction, *uuid.UUID) predicate.Environment); ok {
		r0 = rf(ctx, userID, action, projectID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(predicate.Environment)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, schema.PermittedAction, *uuid.UUID) error); ok {
		r1 = rf(ctx, userID, action, projectID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PermissionsRepositoryMock_GetAccessibleEnvironmentPredicates_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccessibleEnvironmentPredicates'
type PermissionsRepositoryMock_GetAccessibleEnvironmentPredicates_Call struct {
	*mock.Call
}

// GetAccessibleEnvironmentPredicates is a helper method to define mock.On call
//   - ctx context.Context
//   - userID uuid.UUID
//   - action schema.PermittedAction
//   - projectID *uuid.UUID
func (_e *PermissionsRepositoryMock_Expecter) GetAccessibleEnvironmentPredicates(ctx interface{}, userID interface{}, action interface{}, projectID interface{}) *PermissionsRepositoryMock_GetAccessibleEnvironmentPredicates_Call {
	return &PermissionsRepositoryMock_GetAccessibleEnvironmentPredicates_Call{Call: _e.mock.On("GetAccessibleEnvironmentPredicates", ctx, userID, action, projectID)}
}

func (_c *PermissionsRepositoryMock_GetAccessibleEnvironmentPredicates_Call) Run(run func(ctx context.Context, userID uuid.UUID, action schema.PermittedAction, projectID *uuid.UUID)) *PermissionsRepositoryMock_GetAccessibleEnvironmentPredicates_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(schema.PermittedAction), args[3].(*uuid.UUID))
	})
	return _c
}

func (_c *PermissionsRepositoryMock_GetAccessibleEnvironmentPredicates_Call) Return(_a0 predicate.Environment, _a1 error) *PermissionsRepositoryMock_GetAccessibleEnvironmentPredicates_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *PermissionsRepositoryMock_GetAccessibleEnvironmentPredicates_Call) RunAndReturn(run func(context.Context, uuid.UUID, schema.PermittedAction, *uuid.UUID) (predicate.Environment, error)) *PermissionsRepositoryMock_GetAccessibleEnvironmentPredicates_Call {
	_c.Call.Return(run)
	return _c
}

// GetAccessibleProjectPredicates provides a mock function with given fields: ctx, userID, action
func (_m *PermissionsRepositoryMock) GetAccessibleProjectPredicates(ctx context.Context, userID uuid.UUID, action schema.PermittedAction) (predicate.Project, error) {
	ret := _m.Called(ctx, userID, action)

	if len(ret) == 0 {
		panic("no return value specified for GetAccessibleProjectPredicates")
	}

	var r0 predicate.Project
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, schema.PermittedAction) (predicate.Project, error)); ok {
		return rf(ctx, userID, action)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, schema.PermittedAction) predicate.Project); ok {
		r0 = rf(ctx, userID, action)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(predicate.Project)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, schema.PermittedAction) error); ok {
		r1 = rf(ctx, userID, action)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PermissionsRepositoryMock_GetAccessibleProjectPredicates_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccessibleProjectPredicates'
type PermissionsRepositoryMock_GetAccessibleProjectPredicates_Call struct {
	*mock.Call
}

// GetAccessibleProjectPredicates is a helper method to define mock.On call
//   - ctx context.Context
//   - userID uuid.UUID
//   - action schema.PermittedAction
func (_e *PermissionsRepositoryMock_Expecter) GetAccessibleProjectPredicates(ctx interface{}, userID interface{}, action interface{}) *PermissionsRepositoryMock_GetAccessibleProjectPredicates_Call {
	return &PermissionsRepositoryMock_GetAccessibleProjectPredicates_Call{Call: _e.mock.On("GetAccessibleProjectPredicates", ctx, userID, action)}
}

func (_c *PermissionsRepositoryMock_GetAccessibleProjectPredicates_Call) Run(run func(ctx context.Context, userID uuid.UUID, action schema.PermittedAction)) *PermissionsRepositoryMock_GetAccessibleProjectPredicates_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(schema.PermittedAction))
	})
	return _c
}

func (_c *PermissionsRepositoryMock_GetAccessibleProjectPredicates_Call) Return(_a0 predicate.Project, _a1 error) *PermissionsRepositoryMock_GetAccessibleProjectPredicates_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *PermissionsRepositoryMock_GetAccessibleProjectPredicates_Call) RunAndReturn(run func(context.Context, uuid.UUID, schema.PermittedAction) (predicate.Project, error)) *PermissionsRepositoryMock_GetAccessibleProjectPredicates_Call {
	_c.Call.Return(run)
	return _c
}

// GetAccessibleServicePredicates provides a mock function with given fields: ctx, userID, action, environmentID
func (_m *PermissionsRepositoryMock) GetAccessibleServicePredicates(ctx context.Context, userID uuid.UUID, action schema.PermittedAction, environmentID *uuid.UUID) (predicate.Service, error) {
	ret := _m.Called(ctx, userID, action, environmentID)

	if len(ret) == 0 {
		panic("no return value specified for GetAccessibleServicePredicates")
	}

	var r0 predicate.Service
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, schema.PermittedAction, *uuid.UUID) (predicate.Service, error)); ok {
		return rf(ctx, userID, action, environmentID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, schema.PermittedAction, *uuid.UUID) predicate.Service); ok {
		r0 = rf(ctx, userID, action, environmentID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(predicate.Service)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, schema.PermittedAction, *uuid.UUID) error); ok {
		r1 = rf(ctx, userID, action, environmentID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PermissionsRepositoryMock_GetAccessibleServicePredicates_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccessibleServicePredicates'
type PermissionsRepositoryMock_GetAccessibleServicePredicates_Call struct {
	*mock.Call
}

// GetAccessibleServicePredicates is a helper method to define mock.On call
//   - ctx context.Context
//   - userID uuid.UUID
//   - action schema.PermittedAction
//   - environmentID *uuid.UUID
func (_e *PermissionsRepositoryMock_Expecter) GetAccessibleServicePredicates(ctx interface{}, userID interface{}, action interface{}, environmentID interface{}) *PermissionsRepositoryMock_GetAccessibleServicePredicates_Call {
	return &PermissionsRepositoryMock_GetAccessibleServicePredicates_Call{Call: _e.mock.On("GetAccessibleServicePredicates", ctx, userID, action, environmentID)}
}

func (_c *PermissionsRepositoryMock_GetAccessibleServicePredicates_Call) Run(run func(ctx context.Context, userID uuid.UUID, action schema.PermittedAction, environmentID *uuid.UUID)) *PermissionsRepositoryMock_GetAccessibleServicePredicates_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(schema.PermittedAction), args[3].(*uuid.UUID))
	})
	return _c
}

func (_c *PermissionsRepositoryMock_GetAccessibleServicePredicates_Call) Return(_a0 predicate.Service, _a1 error) *PermissionsRepositoryMock_GetAccessibleServicePredicates_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *PermissionsRepositoryMock_GetAccessibleServicePredicates_Call) RunAndReturn(run func(context.Context, uuid.UUID, schema.PermittedAction, *uuid.UUID) (predicate.Service, error)) *PermissionsRepositoryMock_GetAccessibleServicePredicates_Call {
	_c.Call.Return(run)
	return _c
}

// GetAccessibleTeamPredicates provides a mock function with given fields: ctx, userID, action
func (_m *PermissionsRepositoryMock) GetAccessibleTeamPredicates(ctx context.Context, userID uuid.UUID, action schema.PermittedAction) (predicate.Team, error) {
	ret := _m.Called(ctx, userID, action)

	if len(ret) == 0 {
		panic("no return value specified for GetAccessibleTeamPredicates")
	}

	var r0 predicate.Team
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, schema.PermittedAction) (predicate.Team, error)); ok {
		return rf(ctx, userID, action)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, schema.PermittedAction) predicate.Team); ok {
		r0 = rf(ctx, userID, action)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(predicate.Team)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, schema.PermittedAction) error); ok {
		r1 = rf(ctx, userID, action)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PermissionsRepositoryMock_GetAccessibleTeamPredicates_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccessibleTeamPredicates'
type PermissionsRepositoryMock_GetAccessibleTeamPredicates_Call struct {
	*mock.Call
}

// GetAccessibleTeamPredicates is a helper method to define mock.On call
//   - ctx context.Context
//   - userID uuid.UUID
//   - action schema.PermittedAction
func (_e *PermissionsRepositoryMock_Expecter) GetAccessibleTeamPredicates(ctx interface{}, userID interface{}, action interface{}) *PermissionsRepositoryMock_GetAccessibleTeamPredicates_Call {
	return &PermissionsRepositoryMock_GetAccessibleTeamPredicates_Call{Call: _e.mock.On("GetAccessibleTeamPredicates", ctx, userID, action)}
}

func (_c *PermissionsRepositoryMock_GetAccessibleTeamPredicates_Call) Run(run func(ctx context.Context, userID uuid.UUID, action schema.PermittedAction)) *PermissionsRepositoryMock_GetAccessibleTeamPredicates_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(schema.PermittedAction))
	})
	return _c
}

func (_c *PermissionsRepositoryMock_GetAccessibleTeamPredicates_Call) Return(_a0 predicate.Team, _a1 error) *PermissionsRepositoryMock_GetAccessibleTeamPredicates_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *PermissionsRepositoryMock_GetAccessibleTeamPredicates_Call) RunAndReturn(run func(context.Context, uuid.UUID, schema.PermittedAction) (predicate.Team, error)) *PermissionsRepositoryMock_GetAccessibleTeamPredicates_Call {
	_c.Call.Return(run)
	return _c
}

// GetByID provides a mock function with given fields: ctx, id
func (_m *PermissionsRepositoryMock) GetByID(ctx context.Context, id uuid.UUID) (*ent.Permission, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetByID")
	}

	var r0 *ent.Permission
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*ent.Permission, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) *ent.Permission); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ent.Permission)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PermissionsRepositoryMock_GetByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByID'
type PermissionsRepositoryMock_GetByID_Call struct {
	*mock.Call
}

// GetByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
func (_e *PermissionsRepositoryMock_Expecter) GetByID(ctx interface{}, id interface{}) *PermissionsRepositoryMock_GetByID_Call {
	return &PermissionsRepositoryMock_GetByID_Call{Call: _e.mock.On("GetByID", ctx, id)}
}

func (_c *PermissionsRepositoryMock_GetByID_Call) Run(run func(ctx context.Context, id uuid.UUID)) *PermissionsRepositoryMock_GetByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *PermissionsRepositoryMock_GetByID_Call) Return(_a0 *ent.Permission, _a1 error) *PermissionsRepositoryMock_GetByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *PermissionsRepositoryMock_GetByID_Call) RunAndReturn(run func(context.Context, uuid.UUID) (*ent.Permission, error)) *PermissionsRepositoryMock_GetByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetPermissionsByGroup provides a mock function with given fields: ctx, groupID
func (_m *PermissionsRepositoryMock) GetPermissionsByGroup(ctx context.Context, groupID uuid.UUID) ([]*ent.Permission, error) {
	ret := _m.Called(ctx, groupID)

	if len(ret) == 0 {
		panic("no return value specified for GetPermissionsByGroup")
	}

	var r0 []*ent.Permission
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) ([]*ent.Permission, error)); ok {
		return rf(ctx, groupID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) []*ent.Permission); ok {
		r0 = rf(ctx, groupID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*ent.Permission)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, groupID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PermissionsRepositoryMock_GetPermissionsByGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPermissionsByGroup'
type PermissionsRepositoryMock_GetPermissionsByGroup_Call struct {
	*mock.Call
}

// GetPermissionsByGroup is a helper method to define mock.On call
//   - ctx context.Context
//   - groupID uuid.UUID
func (_e *PermissionsRepositoryMock_Expecter) GetPermissionsByGroup(ctx interface{}, groupID interface{}) *PermissionsRepositoryMock_GetPermissionsByGroup_Call {
	return &PermissionsRepositoryMock_GetPermissionsByGroup_Call{Call: _e.mock.On("GetPermissionsByGroup", ctx, groupID)}
}

func (_c *PermissionsRepositoryMock_GetPermissionsByGroup_Call) Run(run func(ctx context.Context, groupID uuid.UUID)) *PermissionsRepositoryMock_GetPermissionsByGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *PermissionsRepositoryMock_GetPermissionsByGroup_Call) Return(_a0 []*ent.Permission, _a1 error) *PermissionsRepositoryMock_GetPermissionsByGroup_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *PermissionsRepositoryMock_GetPermissionsByGroup_Call) RunAndReturn(run func(context.Context, uuid.UUID) ([]*ent.Permission, error)) *PermissionsRepositoryMock_GetPermissionsByGroup_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserPermissionsForResource provides a mock function with given fields: ctx, userID, resourceType, resourceID
func (_m *PermissionsRepositoryMock) GetUserPermissionsForResource(ctx context.Context, userID uuid.UUID, resourceType schema.ResourceType, resourceID uuid.UUID) ([]schema.PermittedAction, error) {
	ret := _m.Called(ctx, userID, resourceType, resourceID)

	if len(ret) == 0 {
		panic("no return value specified for GetUserPermissionsForResource")
	}

	var r0 []schema.PermittedAction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, schema.ResourceType, uuid.UUID) ([]schema.PermittedAction, error)); ok {
		return rf(ctx, userID, resourceType, resourceID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, schema.ResourceType, uuid.UUID) []schema.PermittedAction); ok {
		r0 = rf(ctx, userID, resourceType, resourceID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]schema.PermittedAction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, schema.ResourceType, uuid.UUID) error); ok {
		r1 = rf(ctx, userID, resourceType, resourceID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PermissionsRepositoryMock_GetUserPermissionsForResource_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserPermissionsForResource'
type PermissionsRepositoryMock_GetUserPermissionsForResource_Call struct {
	*mock.Call
}

// GetUserPermissionsForResource is a helper method to define mock.On call
//   - ctx context.Context
//   - userID uuid.UUID
//   - resourceType schema.ResourceType
//   - resourceID uuid.UUID
func (_e *PermissionsRepositoryMock_Expecter) GetUserPermissionsForResource(ctx interface{}, userID interface{}, resourceType interface{}, resourceID interface{}) *PermissionsRepositoryMock_GetUserPermissionsForResource_Call {
	return &PermissionsRepositoryMock_GetUserPermissionsForResource_Call{Call: _e.mock.On("GetUserPermissionsForResource", ctx, userID, resourceType, resourceID)}
}

func (_c *PermissionsRepositoryMock_GetUserPermissionsForResource_Call) Run(run func(ctx context.Context, userID uuid.UUID, resourceType schema.ResourceType, resourceID uuid.UUID)) *PermissionsRepositoryMock_GetUserPermissionsForResource_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(schema.ResourceType), args[3].(uuid.UUID))
	})
	return _c
}

func (_c *PermissionsRepositoryMock_GetUserPermissionsForResource_Call) Return(_a0 []schema.PermittedAction, _a1 error) *PermissionsRepositoryMock_GetUserPermissionsForResource_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *PermissionsRepositoryMock_GetUserPermissionsForResource_Call) RunAndReturn(run func(context.Context, uuid.UUID, schema.ResourceType, uuid.UUID) ([]schema.PermittedAction, error)) *PermissionsRepositoryMock_GetUserPermissionsForResource_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveFromGroup provides a mock function with given fields: ctx, groupID, permissionID
func (_m *PermissionsRepositoryMock) RemoveFromGroup(ctx context.Context, groupID uuid.UUID, permissionID uuid.UUID) error {
	ret := _m.Called(ctx, groupID, permissionID)

	if len(ret) == 0 {
		panic("no return value specified for RemoveFromGroup")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, uuid.UUID) error); ok {
		r0 = rf(ctx, groupID, permissionID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// PermissionsRepositoryMock_RemoveFromGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveFromGroup'
type PermissionsRepositoryMock_RemoveFromGroup_Call struct {
	*mock.Call
}

// RemoveFromGroup is a helper method to define mock.On call
//   - ctx context.Context
//   - groupID uuid.UUID
//   - permissionID uuid.UUID
func (_e *PermissionsRepositoryMock_Expecter) RemoveFromGroup(ctx interface{}, groupID interface{}, permissionID interface{}) *PermissionsRepositoryMock_RemoveFromGroup_Call {
	return &PermissionsRepositoryMock_RemoveFromGroup_Call{Call: _e.mock.On("RemoveFromGroup", ctx, groupID, permissionID)}
}

func (_c *PermissionsRepositoryMock_RemoveFromGroup_Call) Run(run func(ctx context.Context, groupID uuid.UUID, permissionID uuid.UUID)) *PermissionsRepositoryMock_RemoveFromGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(uuid.UUID))
	})
	return _c
}

func (_c *PermissionsRepositoryMock_RemoveFromGroup_Call) Return(_a0 error) *PermissionsRepositoryMock_RemoveFromGroup_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *PermissionsRepositoryMock_RemoveFromGroup_Call) RunAndReturn(run func(context.Context, uuid.UUID, uuid.UUID) error) *PermissionsRepositoryMock_RemoveFromGroup_Call {
	_c.Call.Return(run)
	return _c
}

// NewPermissionsRepositoryMock creates a new instance of PermissionsRepositoryMock. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewPermissionsRepositoryMock(t interface {
	mock.TestingT
	Cleanup(func())
}) *PermissionsRepositoryMock {
	mock := &PermissionsRepositoryMock{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
