// Code generated by mockery v2.53.4. DO NOT EDIT.

package mocks_integrations_github

import (
	context "context"

	ent "github.com/unbindapp/unbind-api/ent"
	github "github.com/unbindapp/unbind-api/internal/integrations/github"

	mock "github.com/stretchr/testify/mock"

	schema "github.com/unbindapp/unbind-api/ent/schema"

	v69github "github.com/google/go-github/v69/github"
)

// GithubClientMock is an autogenerated mock type for the GithubClientInterface type
type GithubClientMock struct {
	mock.Mock
}

type GithubClientMock_Expecter struct {
	mock *mock.Mock
}

func (_m *GithubClientMock) EXPECT() *GithubClientMock_Expecter {
	return &GithubClientMock_Expecter{mock: &_m.Mock}
}

// ClonePublicRepository provides a mock function with given fields: ctx, repoURL, refName, commitSHA
func (_m *GithubClientMock) ClonePublicRepository(ctx context.Context, repoURL string, refName string, commitSHA string) (string, error) {
	ret := _m.Called(ctx, repoURL, refName, commitSHA)

	if len(ret) == 0 {
		panic("no return value specified for ClonePublicRepository")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) (string, error)); ok {
		return rf(ctx, repoURL, refName, commitSHA)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) string); ok {
		r0 = rf(ctx, repoURL, refName, commitSHA)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, repoURL, refName, commitSHA)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GithubClientMock_ClonePublicRepository_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClonePublicRepository'
type GithubClientMock_ClonePublicRepository_Call struct {
	*mock.Call
}

// ClonePublicRepository is a helper method to define mock.On call
//   - ctx context.Context
//   - repoURL string
//   - refName string
//   - commitSHA string
func (_e *GithubClientMock_Expecter) ClonePublicRepository(ctx interface{}, repoURL interface{}, refName interface{}, commitSHA interface{}) *GithubClientMock_ClonePublicRepository_Call {
	return &GithubClientMock_ClonePublicRepository_Call{Call: _e.mock.On("ClonePublicRepository", ctx, repoURL, refName, commitSHA)}
}

func (_c *GithubClientMock_ClonePublicRepository_Call) Run(run func(ctx context.Context, repoURL string, refName string, commitSHA string)) *GithubClientMock_ClonePublicRepository_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *GithubClientMock_ClonePublicRepository_Call) Return(_a0 string, _a1 error) *GithubClientMock_ClonePublicRepository_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *GithubClientMock_ClonePublicRepository_Call) RunAndReturn(run func(context.Context, string, string, string) (string, error)) *GithubClientMock_ClonePublicRepository_Call {
	_c.Call.Return(run)
	return _c
}

// CloneRepository provides a mock function with given fields: ctx, appID, installationID, appPrivateKey, repoURL, refName, commitSHA
func (_m *GithubClientMock) CloneRepository(ctx context.Context, appID int64, installationID int64, appPrivateKey string, repoURL string, refName string, commitSHA string) (string, error) {
	ret := _m.Called(ctx, appID, installationID, appPrivateKey, repoURL, refName, commitSHA)

	if len(ret) == 0 {
		panic("no return value specified for CloneRepository")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, int64, string, string, string, string) (string, error)); ok {
		return rf(ctx, appID, installationID, appPrivateKey, repoURL, refName, commitSHA)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, int64, string, string, string, string) string); ok {
		r0 = rf(ctx, appID, installationID, appPrivateKey, repoURL, refName, commitSHA)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, int64, string, string, string, string) error); ok {
		r1 = rf(ctx, appID, installationID, appPrivateKey, repoURL, refName, commitSHA)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GithubClientMock_CloneRepository_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CloneRepository'
type GithubClientMock_CloneRepository_Call struct {
	*mock.Call
}

// CloneRepository is a helper method to define mock.On call
//   - ctx context.Context
//   - appID int64
//   - installationID int64
//   - appPrivateKey string
//   - repoURL string
//   - refName string
//   - commitSHA string
func (_e *GithubClientMock_Expecter) CloneRepository(ctx interface{}, appID interface{}, installationID interface{}, appPrivateKey interface{}, repoURL interface{}, refName interface{}, commitSHA interface{}) *GithubClientMock_CloneRepository_Call {
	return &GithubClientMock_CloneRepository_Call{Call: _e.mock.On("CloneRepository", ctx, appID, installationID, appPrivateKey, repoURL, refName, commitSHA)}
}

func (_c *GithubClientMock_CloneRepository_Call) Run(run func(ctx context.Context, appID int64, installationID int64, appPrivateKey string, repoURL string, refName string, commitSHA string)) *GithubClientMock_CloneRepository_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64), args[2].(int64), args[3].(string), args[4].(string), args[5].(string), args[6].(string))
	})
	return _c
}

func (_c *GithubClientMock_CloneRepository_Call) Return(_a0 string, _a1 error) *GithubClientMock_CloneRepository_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *GithubClientMock_CloneRepository_Call) RunAndReturn(run func(context.Context, int64, int64, string, string, string, string) (string, error)) *GithubClientMock_CloneRepository_Call {
	_c.Call.Return(run)
	return _c
}

// CreateAppManifest provides a mock function with given fields: redirectUrl, setupUrl, forOrganization
func (_m *GithubClientMock) CreateAppManifest(redirectUrl string, setupUrl string, forOrganization bool) (*github.GitHubAppManifest, string, error) {
	ret := _m.Called(redirectUrl, setupUrl, forOrganization)

	if len(ret) == 0 {
		panic("no return value specified for CreateAppManifest")
	}

	var r0 *github.GitHubAppManifest
	var r1 string
	var r2 error
	if rf, ok := ret.Get(0).(func(string, string, bool) (*github.GitHubAppManifest, string, error)); ok {
		return rf(redirectUrl, setupUrl, forOrganization)
	}
	if rf, ok := ret.Get(0).(func(string, string, bool) *github.GitHubAppManifest); ok {
		r0 = rf(redirectUrl, setupUrl, forOrganization)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*github.GitHubAppManifest)
		}
	}

	if rf, ok := ret.Get(1).(func(string, string, bool) string); ok {
		r1 = rf(redirectUrl, setupUrl, forOrganization)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(string, string, bool) error); ok {
		r2 = rf(redirectUrl, setupUrl, forOrganization)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GithubClientMock_CreateAppManifest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateAppManifest'
type GithubClientMock_CreateAppManifest_Call struct {
	*mock.Call
}

// CreateAppManifest is a helper method to define mock.On call
//   - redirectUrl string
//   - setupUrl string
//   - forOrganization bool
func (_e *GithubClientMock_Expecter) CreateAppManifest(redirectUrl interface{}, setupUrl interface{}, forOrganization interface{}) *GithubClientMock_CreateAppManifest_Call {
	return &GithubClientMock_CreateAppManifest_Call{Call: _e.mock.On("CreateAppManifest", redirectUrl, setupUrl, forOrganization)}
}

func (_c *GithubClientMock_CreateAppManifest_Call) Run(run func(redirectUrl string, setupUrl string, forOrganization bool)) *GithubClientMock_CreateAppManifest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string), args[2].(bool))
	})
	return _c
}

func (_c *GithubClientMock_CreateAppManifest_Call) Return(manifest *github.GitHubAppManifest, appName string, err error) *GithubClientMock_CreateAppManifest_Call {
	_c.Call.Return(manifest, appName, err)
	return _c
}

func (_c *GithubClientMock_CreateAppManifest_Call) RunAndReturn(run func(string, string, bool) (*github.GitHubAppManifest, string, error)) *GithubClientMock_CreateAppManifest_Call {
	_c.Call.Return(run)
	return _c
}

// GetAuthenticatedClient provides a mock function with given fields: ctx, appID, installationID, appPrivateKey
func (_m *GithubClientMock) GetAuthenticatedClient(ctx context.Context, appID int64, installationID int64, appPrivateKey string) (*v69github.Client, error) {
	ret := _m.Called(ctx, appID, installationID, appPrivateKey)

	if len(ret) == 0 {
		panic("no return value specified for GetAuthenticatedClient")
	}

	var r0 *v69github.Client
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, int64, string) (*v69github.Client, error)); ok {
		return rf(ctx, appID, installationID, appPrivateKey)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, int64, string) *v69github.Client); ok {
		r0 = rf(ctx, appID, installationID, appPrivateKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v69github.Client)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, int64, string) error); ok {
		r1 = rf(ctx, appID, installationID, appPrivateKey)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GithubClientMock_GetAuthenticatedClient_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAuthenticatedClient'
type GithubClientMock_GetAuthenticatedClient_Call struct {
	*mock.Call
}

// GetAuthenticatedClient is a helper method to define mock.On call
//   - ctx context.Context
//   - appID int64
//   - installationID int64
//   - appPrivateKey string
func (_e *GithubClientMock_Expecter) GetAuthenticatedClient(ctx interface{}, appID interface{}, installationID interface{}, appPrivateKey interface{}) *GithubClientMock_GetAuthenticatedClient_Call {
	return &GithubClientMock_GetAuthenticatedClient_Call{Call: _e.mock.On("GetAuthenticatedClient", ctx, appID, installationID, appPrivateKey)}
}

func (_c *GithubClientMock_GetAuthenticatedClient_Call) Run(run func(ctx context.Context, appID int64, installationID int64, appPrivateKey string)) *GithubClientMock_GetAuthenticatedClient_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64), args[2].(int64), args[3].(string))
	})
	return _c
}

func (_c *GithubClientMock_GetAuthenticatedClient_Call) Return(_a0 *v69github.Client, _a1 error) *GithubClientMock_GetAuthenticatedClient_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *GithubClientMock_GetAuthenticatedClient_Call) RunAndReturn(run func(context.Context, int64, int64, string) (*v69github.Client, error)) *GithubClientMock_GetAuthenticatedClient_Call {
	_c.Call.Return(run)
	return _c
}

// GetCommitSummary provides a mock function with given fields: ctx, installation, owner, repo, branchOrSHA, isCommitSHA
func (_m *GithubClientMock) GetCommitSummary(ctx context.Context, installation *ent.GithubInstallation, owner string, repo string, branchOrSHA string, isCommitSHA bool) (string, string, *schema.GitCommitter, error) {
	ret := _m.Called(ctx, installation, owner, repo, branchOrSHA, isCommitSHA)

	if len(ret) == 0 {
		panic("no return value specified for GetCommitSummary")
	}

	var r0 string
	var r1 string
	var r2 *schema.GitCommitter
	var r3 error
	if rf, ok := ret.Get(0).(func(context.Context, *ent.GithubInstallation, string, string, string, bool) (string, string, *schema.GitCommitter, error)); ok {
		return rf(ctx, installation, owner, repo, branchOrSHA, isCommitSHA)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ent.GithubInstallation, string, string, string, bool) string); ok {
		r0 = rf(ctx, installation, owner, repo, branchOrSHA, isCommitSHA)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ent.GithubInstallation, string, string, string, bool) string); ok {
		r1 = rf(ctx, installation, owner, repo, branchOrSHA, isCommitSHA)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, *ent.GithubInstallation, string, string, string, bool) *schema.GitCommitter); ok {
		r2 = rf(ctx, installation, owner, repo, branchOrSHA, isCommitSHA)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).(*schema.GitCommitter)
		}
	}

	if rf, ok := ret.Get(3).(func(context.Context, *ent.GithubInstallation, string, string, string, bool) error); ok {
		r3 = rf(ctx, installation, owner, repo, branchOrSHA, isCommitSHA)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// GithubClientMock_GetCommitSummary_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCommitSummary'
type GithubClientMock_GetCommitSummary_Call struct {
	*mock.Call
}

// GetCommitSummary is a helper method to define mock.On call
//   - ctx context.Context
//   - installation *ent.GithubInstallation
//   - owner string
//   - repo string
//   - branchOrSHA string
//   - isCommitSHA bool
func (_e *GithubClientMock_Expecter) GetCommitSummary(ctx interface{}, installation interface{}, owner interface{}, repo interface{}, branchOrSHA interface{}, isCommitSHA interface{}) *GithubClientMock_GetCommitSummary_Call {
	return &GithubClientMock_GetCommitSummary_Call{Call: _e.mock.On("GetCommitSummary", ctx, installation, owner, repo, branchOrSHA, isCommitSHA)}
}

func (_c *GithubClientMock_GetCommitSummary_Call) Run(run func(ctx context.Context, installation *ent.GithubInstallation, owner string, repo string, branchOrSHA string, isCommitSHA bool)) *GithubClientMock_GetCommitSummary_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*ent.GithubInstallation), args[2].(string), args[3].(string), args[4].(string), args[5].(bool))
	})
	return _c
}

func (_c *GithubClientMock_GetCommitSummary_Call) Return(commitSHA string, commitMessage string, committer *schema.GitCommitter, err error) *GithubClientMock_GetCommitSummary_Call {
	_c.Call.Return(commitSHA, commitMessage, committer, err)
	return _c
}

func (_c *GithubClientMock_GetCommitSummary_Call) RunAndReturn(run func(context.Context, *ent.GithubInstallation, string, string, string, bool) (string, string, *schema.GitCommitter, error)) *GithubClientMock_GetCommitSummary_Call {
	_c.Call.Return(run)
	return _c
}

// GetInstallationToken provides a mock function with given fields: ctx, appID, installationID, appPrivateKey
func (_m *GithubClientMock) GetInstallationToken(ctx context.Context, appID int64, installationID int64, appPrivateKey string) (string, error) {
	ret := _m.Called(ctx, appID, installationID, appPrivateKey)

	if len(ret) == 0 {
		panic("no return value specified for GetInstallationToken")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, int64, string) (string, error)); ok {
		return rf(ctx, appID, installationID, appPrivateKey)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, int64, string) string); ok {
		r0 = rf(ctx, appID, installationID, appPrivateKey)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, int64, string) error); ok {
		r1 = rf(ctx, appID, installationID, appPrivateKey)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GithubClientMock_GetInstallationToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetInstallationToken'
type GithubClientMock_GetInstallationToken_Call struct {
	*mock.Call
}

// GetInstallationToken is a helper method to define mock.On call
//   - ctx context.Context
//   - appID int64
//   - installationID int64
//   - appPrivateKey string
func (_e *GithubClientMock_Expecter) GetInstallationToken(ctx interface{}, appID interface{}, installationID interface{}, appPrivateKey interface{}) *GithubClientMock_GetInstallationToken_Call {
	return &GithubClientMock_GetInstallationToken_Call{Call: _e.mock.On("GetInstallationToken", ctx, appID, installationID, appPrivateKey)}
}

func (_c *GithubClientMock_GetInstallationToken_Call) Run(run func(ctx context.Context, appID int64, installationID int64, appPrivateKey string)) *GithubClientMock_GetInstallationToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64), args[2].(int64), args[3].(string))
	})
	return _c
}

func (_c *GithubClientMock_GetInstallationToken_Call) Return(_a0 string, _a1 error) *GithubClientMock_GetInstallationToken_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *GithubClientMock_GetInstallationToken_Call) RunAndReturn(run func(context.Context, int64, int64, string) (string, error)) *GithubClientMock_GetInstallationToken_Call {
	_c.Call.Return(run)
	return _c
}

// GetRepositoryDetail provides a mock function with given fields: ctx, installation, owner, repo
func (_m *GithubClientMock) GetRepositoryDetail(ctx context.Context, installation *ent.GithubInstallation, owner string, repo string) (*github.GithubRepositoryDetail, error) {
	ret := _m.Called(ctx, installation, owner, repo)

	if len(ret) == 0 {
		panic("no return value specified for GetRepositoryDetail")
	}

	var r0 *github.GithubRepositoryDetail
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ent.GithubInstallation, string, string) (*github.GithubRepositoryDetail, error)); ok {
		return rf(ctx, installation, owner, repo)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ent.GithubInstallation, string, string) *github.GithubRepositoryDetail); ok {
		r0 = rf(ctx, installation, owner, repo)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*github.GithubRepositoryDetail)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ent.GithubInstallation, string, string) error); ok {
		r1 = rf(ctx, installation, owner, repo)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GithubClientMock_GetRepositoryDetail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRepositoryDetail'
type GithubClientMock_GetRepositoryDetail_Call struct {
	*mock.Call
}

// GetRepositoryDetail is a helper method to define mock.On call
//   - ctx context.Context
//   - installation *ent.GithubInstallation
//   - owner string
//   - repo string
func (_e *GithubClientMock_Expecter) GetRepositoryDetail(ctx interface{}, installation interface{}, owner interface{}, repo interface{}) *GithubClientMock_GetRepositoryDetail_Call {
	return &GithubClientMock_GetRepositoryDetail_Call{Call: _e.mock.On("GetRepositoryDetail", ctx, installation, owner, repo)}
}

func (_c *GithubClientMock_GetRepositoryDetail_Call) Run(run func(ctx context.Context, installation *ent.GithubInstallation, owner string, repo string)) *GithubClientMock_GetRepositoryDetail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*ent.GithubInstallation), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *GithubClientMock_GetRepositoryDetail_Call) Return(_a0 *github.GithubRepositoryDetail, _a1 error) *GithubClientMock_GetRepositoryDetail_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *GithubClientMock_GetRepositoryDetail_Call) RunAndReturn(run func(context.Context, *ent.GithubInstallation, string, string) (*github.GithubRepositoryDetail, error)) *GithubClientMock_GetRepositoryDetail_Call {
	_c.Call.Return(run)
	return _c
}

// ManifestCodeConversion provides a mock function with given fields: ctx, code
func (_m *GithubClientMock) ManifestCodeConversion(ctx context.Context, code string) (*v69github.AppConfig, error) {
	ret := _m.Called(ctx, code)

	if len(ret) == 0 {
		panic("no return value specified for ManifestCodeConversion")
	}

	var r0 *v69github.AppConfig
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*v69github.AppConfig, error)); ok {
		return rf(ctx, code)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *v69github.AppConfig); ok {
		r0 = rf(ctx, code)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v69github.AppConfig)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, code)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GithubClientMock_ManifestCodeConversion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ManifestCodeConversion'
type GithubClientMock_ManifestCodeConversion_Call struct {
	*mock.Call
}

// ManifestCodeConversion is a helper method to define mock.On call
//   - ctx context.Context
//   - code string
func (_e *GithubClientMock_Expecter) ManifestCodeConversion(ctx interface{}, code interface{}) *GithubClientMock_ManifestCodeConversion_Call {
	return &GithubClientMock_ManifestCodeConversion_Call{Call: _e.mock.On("ManifestCodeConversion", ctx, code)}
}

func (_c *GithubClientMock_ManifestCodeConversion_Call) Run(run func(ctx context.Context, code string)) *GithubClientMock_ManifestCodeConversion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *GithubClientMock_ManifestCodeConversion_Call) Return(_a0 *v69github.AppConfig, _a1 error) *GithubClientMock_ManifestCodeConversion_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *GithubClientMock_ManifestCodeConversion_Call) RunAndReturn(run func(context.Context, string) (*v69github.AppConfig, error)) *GithubClientMock_ManifestCodeConversion_Call {
	_c.Call.Return(run)
	return _c
}

// ReadUserAdminOrganizations provides a mock function with given fields: ctx, installation
func (_m *GithubClientMock) ReadUserAdminOrganizations(ctx context.Context, installation *ent.GithubInstallation) ([]*v69github.Organization, error) {
	ret := _m.Called(ctx, installation)

	if len(ret) == 0 {
		panic("no return value specified for ReadUserAdminOrganizations")
	}

	var r0 []*v69github.Organization
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *ent.GithubInstallation) ([]*v69github.Organization, error)); ok {
		return rf(ctx, installation)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ent.GithubInstallation) []*v69github.Organization); ok {
		r0 = rf(ctx, installation)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*v69github.Organization)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ent.GithubInstallation) error); ok {
		r1 = rf(ctx, installation)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GithubClientMock_ReadUserAdminOrganizations_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadUserAdminOrganizations'
type GithubClientMock_ReadUserAdminOrganizations_Call struct {
	*mock.Call
}

// ReadUserAdminOrganizations is a helper method to define mock.On call
//   - ctx context.Context
//   - installation *ent.GithubInstallation
func (_e *GithubClientMock_Expecter) ReadUserAdminOrganizations(ctx interface{}, installation interface{}) *GithubClientMock_ReadUserAdminOrganizations_Call {
	return &GithubClientMock_ReadUserAdminOrganizations_Call{Call: _e.mock.On("ReadUserAdminOrganizations", ctx, installation)}
}

func (_c *GithubClientMock_ReadUserAdminOrganizations_Call) Run(run func(ctx context.Context, installation *ent.GithubInstallation)) *GithubClientMock_ReadUserAdminOrganizations_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*ent.GithubInstallation))
	})
	return _c
}

func (_c *GithubClientMock_ReadUserAdminOrganizations_Call) Return(_a0 []*v69github.Organization, _a1 error) *GithubClientMock_ReadUserAdminOrganizations_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *GithubClientMock_ReadUserAdminOrganizations_Call) RunAndReturn(run func(context.Context, *ent.GithubInstallation) ([]*v69github.Organization, error)) *GithubClientMock_ReadUserAdminOrganizations_Call {
	_c.Call.Return(run)
	return _c
}

// ReadUserAdminRepositories provides a mock function with given fields: ctx, installations
func (_m *GithubClientMock) ReadUserAdminRepositories(ctx context.Context, installations []*ent.GithubInstallation) ([]*github.GithubRepository, error) {
	ret := _m.Called(ctx, installations)

	if len(ret) == 0 {
		panic("no return value specified for ReadUserAdminRepositories")
	}

	var r0 []*github.GithubRepository
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []*ent.GithubInstallation) ([]*github.GithubRepository, error)); ok {
		return rf(ctx, installations)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []*ent.GithubInstallation) []*github.GithubRepository); ok {
		r0 = rf(ctx, installations)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*github.GithubRepository)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []*ent.GithubInstallation) error); ok {
		r1 = rf(ctx, installations)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GithubClientMock_ReadUserAdminRepositories_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadUserAdminRepositories'
type GithubClientMock_ReadUserAdminRepositories_Call struct {
	*mock.Call
}

// ReadUserAdminRepositories is a helper method to define mock.On call
//   - ctx context.Context
//   - installations []*ent.GithubInstallation
func (_e *GithubClientMock_Expecter) ReadUserAdminRepositories(ctx interface{}, installations interface{}) *GithubClientMock_ReadUserAdminRepositories_Call {
	return &GithubClientMock_ReadUserAdminRepositories_Call{Call: _e.mock.On("ReadUserAdminRepositories", ctx, installations)}
}

func (_c *GithubClientMock_ReadUserAdminRepositories_Call) Run(run func(ctx context.Context, installations []*ent.GithubInstallation)) *GithubClientMock_ReadUserAdminRepositories_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]*ent.GithubInstallation))
	})
	return _c
}

func (_c *GithubClientMock_ReadUserAdminRepositories_Call) Return(_a0 []*github.GithubRepository, _a1 error) *GithubClientMock_ReadUserAdminRepositories_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *GithubClientMock_ReadUserAdminRepositories_Call) RunAndReturn(run func(context.Context, []*ent.GithubInstallation) ([]*github.GithubRepository, error)) *GithubClientMock_ReadUserAdminRepositories_Call {
	_c.Call.Return(run)
	return _c
}

// VerifyRepositoryAccess provides a mock function with given fields: ctx, installation, owner, repo
func (_m *GithubClientMock) VerifyRepositoryAccess(ctx context.Context, installation *ent.GithubInstallation, owner string, repo string) (bool, string, string, error) {
	ret := _m.Called(ctx, installation, owner, repo)

	if len(ret) == 0 {
		panic("no return value specified for VerifyRepositoryAccess")
	}

	var r0 bool
	var r1 string
	var r2 string
	var r3 error
	if rf, ok := ret.Get(0).(func(context.Context, *ent.GithubInstallation, string, string) (bool, string, string, error)); ok {
		return rf(ctx, installation, owner, repo)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *ent.GithubInstallation, string, string) bool); ok {
		r0 = rf(ctx, installation, owner, repo)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *ent.GithubInstallation, string, string) string); ok {
		r1 = rf(ctx, installation, owner, repo)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, *ent.GithubInstallation, string, string) string); ok {
		r2 = rf(ctx, installation, owner, repo)
	} else {
		r2 = ret.Get(2).(string)
	}

	if rf, ok := ret.Get(3).(func(context.Context, *ent.GithubInstallation, string, string) error); ok {
		r3 = rf(ctx, installation, owner, repo)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// GithubClientMock_VerifyRepositoryAccess_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VerifyRepositoryAccess'
type GithubClientMock_VerifyRepositoryAccess_Call struct {
	*mock.Call
}

// VerifyRepositoryAccess is a helper method to define mock.On call
//   - ctx context.Context
//   - installation *ent.GithubInstallation
//   - owner string
//   - repo string
func (_e *GithubClientMock_Expecter) VerifyRepositoryAccess(ctx interface{}, installation interface{}, owner interface{}, repo interface{}) *GithubClientMock_VerifyRepositoryAccess_Call {
	return &GithubClientMock_VerifyRepositoryAccess_Call{Call: _e.mock.On("VerifyRepositoryAccess", ctx, installation, owner, repo)}
}

func (_c *GithubClientMock_VerifyRepositoryAccess_Call) Run(run func(ctx context.Context, installation *ent.GithubInstallation, owner string, repo string)) *GithubClientMock_VerifyRepositoryAccess_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*ent.GithubInstallation), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *GithubClientMock_VerifyRepositoryAccess_Call) Return(canAccess bool, repoUrl string, defaultBranch string, err error) *GithubClientMock_VerifyRepositoryAccess_Call {
	_c.Call.Return(canAccess, repoUrl, defaultBranch, err)
	return _c
}

func (_c *GithubClientMock_VerifyRepositoryAccess_Call) RunAndReturn(run func(context.Context, *ent.GithubInstallation, string, string) (bool, string, string, error)) *GithubClientMock_VerifyRepositoryAccess_Call {
	_c.Call.Return(run)
	return _c
}

// NewGithubClientMock creates a new instance of GithubClientMock. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewGithubClientMock(t interface {
	mock.TestingT
	Cleanup(func())
}) *GithubClientMock {
	mock := &GithubClientMock{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
