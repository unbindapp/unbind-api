// Code generated by mockery v2.53.4. DO NOT EDIT.

package mocks_infrastructure_k8s

import (
	context "context"

	apiv1 "github.com/unbindapp/unbind-operator/api/v1"

	ent "github.com/unbindapp/unbind-api/ent"

	k8s "github.com/unbindapp/unbind-api/internal/infrastructure/k8s"

	kubernetes "k8s.io/client-go/kubernetes"

	loki "github.com/unbindapp/unbind-api/internal/infrastructure/loki"

	mock "github.com/stretchr/testify/mock"

	models "github.com/unbindapp/unbind-api/internal/models"

	networkingv1 "k8s.io/api/networking/v1"

	unstructured "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"

	uuid "github.com/google/uuid"

	v1 "k8s.io/api/core/v1"
)

// KubeClientMock is an autogenerated mock type for the KubeClientInterface type
type KubeClientMock struct {
	mock.Mock
}

type KubeClientMock_Expecter struct {
	mock *mock.Mock
}

func (_m *KubeClientMock) EXPECT() *KubeClientMock_Expecter {
	return &KubeClientMock_Expecter{mock: &_m.Mock}
}

// ApplyYAML provides a mock function with given fields: ctx, yaml
func (_m *KubeClientMock) ApplyYAML(ctx context.Context, yaml []byte) error {
	ret := _m.Called(ctx, yaml)

	if len(ret) == 0 {
		panic("no return value specified for ApplyYAML")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []byte) error); ok {
		r0 = rf(ctx, yaml)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// KubeClientMock_ApplyYAML_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ApplyYAML'
type KubeClientMock_ApplyYAML_Call struct {
	*mock.Call
}

// ApplyYAML is a helper method to define mock.On call
//   - ctx context.Context
//   - yaml []byte
func (_e *KubeClientMock_Expecter) ApplyYAML(ctx interface{}, yaml interface{}) *KubeClientMock_ApplyYAML_Call {
	return &KubeClientMock_ApplyYAML_Call{Call: _e.mock.On("ApplyYAML", ctx, yaml)}
}

func (_c *KubeClientMock_ApplyYAML_Call) Run(run func(ctx context.Context, yaml []byte)) *KubeClientMock_ApplyYAML_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]byte))
	})
	return _c
}

func (_c *KubeClientMock_ApplyYAML_Call) Return(_a0 error) *KubeClientMock_ApplyYAML_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *KubeClientMock_ApplyYAML_Call) RunAndReturn(run func(context.Context, []byte) error) *KubeClientMock_ApplyYAML_Call {
	_c.Call.Return(run)
	return _c
}

// AvailableStorageBytes provides a mock function with given fields: ctx
func (_m *KubeClientMock) AvailableStorageBytes(ctx context.Context) (*k8s.StorageMetadata, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for AvailableStorageBytes")
	}

	var r0 *k8s.StorageMetadata
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*k8s.StorageMetadata, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *k8s.StorageMetadata); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*k8s.StorageMetadata)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KubeClientMock_AvailableStorageBytes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AvailableStorageBytes'
type KubeClientMock_AvailableStorageBytes_Call struct {
	*mock.Call
}

// AvailableStorageBytes is a helper method to define mock.On call
//   - ctx context.Context
func (_e *KubeClientMock_Expecter) AvailableStorageBytes(ctx interface{}) *KubeClientMock_AvailableStorageBytes_Call {
	return &KubeClientMock_AvailableStorageBytes_Call{Call: _e.mock.On("AvailableStorageBytes", ctx)}
}

func (_c *KubeClientMock_AvailableStorageBytes_Call) Run(run func(ctx context.Context)) *KubeClientMock_AvailableStorageBytes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *KubeClientMock_AvailableStorageBytes_Call) Return(_a0 *k8s.StorageMetadata, _a1 error) *KubeClientMock_AvailableStorageBytes_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KubeClientMock_AvailableStorageBytes_Call) RunAndReturn(run func(context.Context) (*k8s.StorageMetadata, error)) *KubeClientMock_AvailableStorageBytes_Call {
	_c.Call.Return(run)
	return _c
}

// CancelJobsByServiceID provides a mock function with given fields: ctx, serviceID
func (_m *KubeClientMock) CancelJobsByServiceID(ctx context.Context, serviceID string) error {
	ret := _m.Called(ctx, serviceID)

	if len(ret) == 0 {
		panic("no return value specified for CancelJobsByServiceID")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, serviceID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// KubeClientMock_CancelJobsByServiceID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CancelJobsByServiceID'
type KubeClientMock_CancelJobsByServiceID_Call struct {
	*mock.Call
}

// CancelJobsByServiceID is a helper method to define mock.On call
//   - ctx context.Context
//   - serviceID string
func (_e *KubeClientMock_Expecter) CancelJobsByServiceID(ctx interface{}, serviceID interface{}) *KubeClientMock_CancelJobsByServiceID_Call {
	return &KubeClientMock_CancelJobsByServiceID_Call{Call: _e.mock.On("CancelJobsByServiceID", ctx, serviceID)}
}

func (_c *KubeClientMock_CancelJobsByServiceID_Call) Run(run func(ctx context.Context, serviceID string)) *KubeClientMock_CancelJobsByServiceID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *KubeClientMock_CancelJobsByServiceID_Call) Return(_a0 error) *KubeClientMock_CancelJobsByServiceID_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *KubeClientMock_CancelJobsByServiceID_Call) RunAndReturn(run func(context.Context, string) error) *KubeClientMock_CancelJobsByServiceID_Call {
	_c.Call.Return(run)
	return _c
}

// CheckDeploymentsReady provides a mock function with given fields: ctx, version
func (_m *KubeClientMock) CheckDeploymentsReady(ctx context.Context, version string) (bool, error) {
	ret := _m.Called(ctx, version)

	if len(ret) == 0 {
		panic("no return value specified for CheckDeploymentsReady")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (bool, error)); ok {
		return rf(ctx, version)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) bool); ok {
		r0 = rf(ctx, version)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, version)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KubeClientMock_CheckDeploymentsReady_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckDeploymentsReady'
type KubeClientMock_CheckDeploymentsReady_Call struct {
	*mock.Call
}

// CheckDeploymentsReady is a helper method to define mock.On call
//   - ctx context.Context
//   - version string
func (_e *KubeClientMock_Expecter) CheckDeploymentsReady(ctx interface{}, version interface{}) *KubeClientMock_CheckDeploymentsReady_Call {
	return &KubeClientMock_CheckDeploymentsReady_Call{Call: _e.mock.On("CheckDeploymentsReady", ctx, version)}
}

func (_c *KubeClientMock_CheckDeploymentsReady_Call) Run(run func(ctx context.Context, version string)) *KubeClientMock_CheckDeploymentsReady_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *KubeClientMock_CheckDeploymentsReady_Call) Return(_a0 bool, _a1 error) *KubeClientMock_CheckDeploymentsReady_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KubeClientMock_CheckDeploymentsReady_Call) RunAndReturn(run func(context.Context, string) (bool, error)) *KubeClientMock_CheckDeploymentsReady_Call {
	_c.Call.Return(run)
	return _c
}

// CopySecret provides a mock function with given fields: ctx, secretName, sourceNamespace, targetNamespace, client
func (_m *KubeClientMock) CopySecret(ctx context.Context, secretName string, sourceNamespace string, targetNamespace string, client kubernetes.Interface) (*v1.Secret, error) {
	ret := _m.Called(ctx, secretName, sourceNamespace, targetNamespace, client)

	if len(ret) == 0 {
		panic("no return value specified for CopySecret")
	}

	var r0 *v1.Secret
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, kubernetes.Interface) (*v1.Secret, error)); ok {
		return rf(ctx, secretName, sourceNamespace, targetNamespace, client)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, kubernetes.Interface) *v1.Secret); ok {
		r0 = rf(ctx, secretName, sourceNamespace, targetNamespace, client)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1.Secret)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, kubernetes.Interface) error); ok {
		r1 = rf(ctx, secretName, sourceNamespace, targetNamespace, client)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KubeClientMock_CopySecret_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CopySecret'
type KubeClientMock_CopySecret_Call struct {
	*mock.Call
}

// CopySecret is a helper method to define mock.On call
//   - ctx context.Context
//   - secretName string
//   - sourceNamespace string
//   - targetNamespace string
//   - client kubernetes.Interface
func (_e *KubeClientMock_Expecter) CopySecret(ctx interface{}, secretName interface{}, sourceNamespace interface{}, targetNamespace interface{}, client interface{}) *KubeClientMock_CopySecret_Call {
	return &KubeClientMock_CopySecret_Call{Call: _e.mock.On("CopySecret", ctx, secretName, sourceNamespace, targetNamespace, client)}
}

func (_c *KubeClientMock_CopySecret_Call) Run(run func(ctx context.Context, secretName string, sourceNamespace string, targetNamespace string, client kubernetes.Interface)) *KubeClientMock_CopySecret_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(kubernetes.Interface))
	})
	return _c
}

func (_c *KubeClientMock_CopySecret_Call) Return(_a0 *v1.Secret, _a1 error) *KubeClientMock_CopySecret_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KubeClientMock_CopySecret_Call) RunAndReturn(run func(context.Context, string, string, string, kubernetes.Interface) (*v1.Secret, error)) *KubeClientMock_CopySecret_Call {
	_c.Call.Return(run)
	return _c
}

// CountActiveDeploymentJobs provides a mock function with given fields: ctx
func (_m *KubeClientMock) CountActiveDeploymentJobs(ctx context.Context) (int, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for CountActiveDeploymentJobs")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (int, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) int); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KubeClientMock_CountActiveDeploymentJobs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CountActiveDeploymentJobs'
type KubeClientMock_CountActiveDeploymentJobs_Call struct {
	*mock.Call
}

// CountActiveDeploymentJobs is a helper method to define mock.On call
//   - ctx context.Context
func (_e *KubeClientMock_Expecter) CountActiveDeploymentJobs(ctx interface{}) *KubeClientMock_CountActiveDeploymentJobs_Call {
	return &KubeClientMock_CountActiveDeploymentJobs_Call{Call: _e.mock.On("CountActiveDeploymentJobs", ctx)}
}

func (_c *KubeClientMock_CountActiveDeploymentJobs_Call) Run(run func(ctx context.Context)) *KubeClientMock_CountActiveDeploymentJobs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *KubeClientMock_CountActiveDeploymentJobs_Call) Return(_a0 int, _a1 error) *KubeClientMock_CountActiveDeploymentJobs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KubeClientMock_CountActiveDeploymentJobs_Call) RunAndReturn(run func(context.Context) (int, error)) *KubeClientMock_CountActiveDeploymentJobs_Call {
	_c.Call.Return(run)
	return _c
}

// CreateClientWithToken provides a mock function with given fields: token
func (_m *KubeClientMock) CreateClientWithToken(token string) (kubernetes.Interface, error) {
	ret := _m.Called(token)

	if len(ret) == 0 {
		panic("no return value specified for CreateClientWithToken")
	}

	var r0 kubernetes.Interface
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (kubernetes.Interface, error)); ok {
		return rf(token)
	}
	if rf, ok := ret.Get(0).(func(string) kubernetes.Interface); ok {
		r0 = rf(token)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kubernetes.Interface)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(token)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KubeClientMock_CreateClientWithToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateClientWithToken'
type KubeClientMock_CreateClientWithToken_Call struct {
	*mock.Call
}

// CreateClientWithToken is a helper method to define mock.On call
//   - token string
func (_e *KubeClientMock_Expecter) CreateClientWithToken(token interface{}) *KubeClientMock_CreateClientWithToken_Call {
	return &KubeClientMock_CreateClientWithToken_Call{Call: _e.mock.On("CreateClientWithToken", token)}
}

func (_c *KubeClientMock_CreateClientWithToken_Call) Run(run func(token string)) *KubeClientMock_CreateClientWithToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *KubeClientMock_CreateClientWithToken_Call) Return(_a0 kubernetes.Interface, _a1 error) *KubeClientMock_CreateClientWithToken_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KubeClientMock_CreateClientWithToken_Call) RunAndReturn(run func(string) (kubernetes.Interface, error)) *KubeClientMock_CreateClientWithToken_Call {
	_c.Call.Return(run)
	return _c
}

// CreateDeployment provides a mock function with given fields: ctx, deploymentID, env
func (_m *KubeClientMock) CreateDeployment(ctx context.Context, deploymentID string, env map[string]string) (string, error) {
	ret := _m.Called(ctx, deploymentID, env)

	if len(ret) == 0 {
		panic("no return value specified for CreateDeployment")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]string) (string, error)); ok {
		return rf(ctx, deploymentID, env)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]string) string); ok {
		r0 = rf(ctx, deploymentID, env)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, map[string]string) error); ok {
		r1 = rf(ctx, deploymentID, env)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KubeClientMock_CreateDeployment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateDeployment'
type KubeClientMock_CreateDeployment_Call struct {
	*mock.Call
}

// CreateDeployment is a helper method to define mock.On call
//   - ctx context.Context
//   - deploymentID string
//   - env map[string]string
func (_e *KubeClientMock_Expecter) CreateDeployment(ctx interface{}, deploymentID interface{}, env interface{}) *KubeClientMock_CreateDeployment_Call {
	return &KubeClientMock_CreateDeployment_Call{Call: _e.mock.On("CreateDeployment", ctx, deploymentID, env)}
}

func (_c *KubeClientMock_CreateDeployment_Call) Run(run func(ctx context.Context, deploymentID string, env map[string]string)) *KubeClientMock_CreateDeployment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(map[string]string))
	})
	return _c
}

func (_c *KubeClientMock_CreateDeployment_Call) Return(jobName string, err error) *KubeClientMock_CreateDeployment_Call {
	_c.Call.Return(jobName, err)
	return _c
}

func (_c *KubeClientMock_CreateDeployment_Call) RunAndReturn(run func(context.Context, string, map[string]string) (string, error)) *KubeClientMock_CreateDeployment_Call {
	_c.Call.Return(run)
	return _c
}

// CreateMultiRegistryCredentials provides a mock function with given fields: ctx, name, namespace, credentials, client
func (_m *KubeClientMock) CreateMultiRegistryCredentials(ctx context.Context, name string, namespace string, credentials []k8s.RegistryCredential, client kubernetes.Interface) (*v1.Secret, error) {
	ret := _m.Called(ctx, name, namespace, credentials, client)

	if len(ret) == 0 {
		panic("no return value specified for CreateMultiRegistryCredentials")
	}

	var r0 *v1.Secret
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, []k8s.RegistryCredential, kubernetes.Interface) (*v1.Secret, error)); ok {
		return rf(ctx, name, namespace, credentials, client)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, []k8s.RegistryCredential, kubernetes.Interface) *v1.Secret); ok {
		r0 = rf(ctx, name, namespace, credentials, client)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1.Secret)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, []k8s.RegistryCredential, kubernetes.Interface) error); ok {
		r1 = rf(ctx, name, namespace, credentials, client)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KubeClientMock_CreateMultiRegistryCredentials_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateMultiRegistryCredentials'
type KubeClientMock_CreateMultiRegistryCredentials_Call struct {
	*mock.Call
}

// CreateMultiRegistryCredentials is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - namespace string
//   - credentials []k8s.RegistryCredential
//   - client kubernetes.Interface
func (_e *KubeClientMock_Expecter) CreateMultiRegistryCredentials(ctx interface{}, name interface{}, namespace interface{}, credentials interface{}, client interface{}) *KubeClientMock_CreateMultiRegistryCredentials_Call {
	return &KubeClientMock_CreateMultiRegistryCredentials_Call{Call: _e.mock.On("CreateMultiRegistryCredentials", ctx, name, namespace, credentials, client)}
}

func (_c *KubeClientMock_CreateMultiRegistryCredentials_Call) Run(run func(ctx context.Context, name string, namespace string, credentials []k8s.RegistryCredential, client kubernetes.Interface)) *KubeClientMock_CreateMultiRegistryCredentials_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].([]k8s.RegistryCredential), args[4].(kubernetes.Interface))
	})
	return _c
}

func (_c *KubeClientMock_CreateMultiRegistryCredentials_Call) Return(_a0 *v1.Secret, _a1 error) *KubeClientMock_CreateMultiRegistryCredentials_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KubeClientMock_CreateMultiRegistryCredentials_Call) RunAndReturn(run func(context.Context, string, string, []k8s.RegistryCredential, kubernetes.Interface) (*v1.Secret, error)) *KubeClientMock_CreateMultiRegistryCredentials_Call {
	_c.Call.Return(run)
	return _c
}

// CreateNamespace provides a mock function with given fields: ctx, namespaceName, client
func (_m *KubeClientMock) CreateNamespace(ctx context.Context, namespaceName string, client kubernetes.Interface) (*v1.Namespace, error) {
	ret := _m.Called(ctx, namespaceName, client)

	if len(ret) == 0 {
		panic("no return value specified for CreateNamespace")
	}

	var r0 *v1.Namespace
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, kubernetes.Interface) (*v1.Namespace, error)); ok {
		return rf(ctx, namespaceName, client)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, kubernetes.Interface) *v1.Namespace); ok {
		r0 = rf(ctx, namespaceName, client)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1.Namespace)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, kubernetes.Interface) error); ok {
		r1 = rf(ctx, namespaceName, client)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KubeClientMock_CreateNamespace_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateNamespace'
type KubeClientMock_CreateNamespace_Call struct {
	*mock.Call
}

// CreateNamespace is a helper method to define mock.On call
//   - ctx context.Context
//   - namespaceName string
//   - client kubernetes.Interface
func (_e *KubeClientMock_Expecter) CreateNamespace(ctx interface{}, namespaceName interface{}, client interface{}) *KubeClientMock_CreateNamespace_Call {
	return &KubeClientMock_CreateNamespace_Call{Call: _e.mock.On("CreateNamespace", ctx, namespaceName, client)}
}

func (_c *KubeClientMock_CreateNamespace_Call) Run(run func(ctx context.Context, namespaceName string, client kubernetes.Interface)) *KubeClientMock_CreateNamespace_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(kubernetes.Interface))
	})
	return _c
}

func (_c *KubeClientMock_CreateNamespace_Call) Return(_a0 *v1.Namespace, _a1 error) *KubeClientMock_CreateNamespace_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KubeClientMock_CreateNamespace_Call) RunAndReturn(run func(context.Context, string, kubernetes.Interface) (*v1.Namespace, error)) *KubeClientMock_CreateNamespace_Call {
	_c.Call.Return(run)
	return _c
}

// CreatePersistentVolumeClaim provides a mock function with given fields: ctx, namespace, pvcName, displayName, labels, storageRequest, accessModes, storageClassName, client
func (_m *KubeClientMock) CreatePersistentVolumeClaim(ctx context.Context, namespace string, pvcName string, displayName string, labels map[string]string, storageRequest string, accessModes []v1.PersistentVolumeAccessMode, storageClassName *string, client kubernetes.Interface) (*models.PVCInfo, error) {
	ret := _m.Called(ctx, namespace, pvcName, displayName, labels, storageRequest, accessModes, storageClassName, client)

	if len(ret) == 0 {
		panic("no return value specified for CreatePersistentVolumeClaim")
	}

	var r0 *models.PVCInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, map[string]string, string, []v1.PersistentVolumeAccessMode, *string, kubernetes.Interface) (*models.PVCInfo, error)); ok {
		return rf(ctx, namespace, pvcName, displayName, labels, storageRequest, accessModes, storageClassName, client)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, map[string]string, string, []v1.PersistentVolumeAccessMode, *string, kubernetes.Interface) *models.PVCInfo); ok {
		r0 = rf(ctx, namespace, pvcName, displayName, labels, storageRequest, accessModes, storageClassName, client)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.PVCInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, map[string]string, string, []v1.PersistentVolumeAccessMode, *string, kubernetes.Interface) error); ok {
		r1 = rf(ctx, namespace, pvcName, displayName, labels, storageRequest, accessModes, storageClassName, client)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KubeClientMock_CreatePersistentVolumeClaim_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreatePersistentVolumeClaim'
type KubeClientMock_CreatePersistentVolumeClaim_Call struct {
	*mock.Call
}

// CreatePersistentVolumeClaim is a helper method to define mock.On call
//   - ctx context.Context
//   - namespace string
//   - pvcName string
//   - displayName string
//   - labels map[string]string
//   - storageRequest string
//   - accessModes []v1.PersistentVolumeAccessMode
//   - storageClassName *string
//   - client kubernetes.Interface
func (_e *KubeClientMock_Expecter) CreatePersistentVolumeClaim(ctx interface{}, namespace interface{}, pvcName interface{}, displayName interface{}, labels interface{}, storageRequest interface{}, accessModes interface{}, storageClassName interface{}, client interface{}) *KubeClientMock_CreatePersistentVolumeClaim_Call {
	return &KubeClientMock_CreatePersistentVolumeClaim_Call{Call: _e.mock.On("CreatePersistentVolumeClaim", ctx, namespace, pvcName, displayName, labels, storageRequest, accessModes, storageClassName, client)}
}

func (_c *KubeClientMock_CreatePersistentVolumeClaim_Call) Run(run func(ctx context.Context, namespace string, pvcName string, displayName string, labels map[string]string, storageRequest string, accessModes []v1.PersistentVolumeAccessMode, storageClassName *string, client kubernetes.Interface)) *KubeClientMock_CreatePersistentVolumeClaim_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(map[string]string), args[5].(string), args[6].([]v1.PersistentVolumeAccessMode), args[7].(*string), args[8].(kubernetes.Interface))
	})
	return _c
}

func (_c *KubeClientMock_CreatePersistentVolumeClaim_Call) Return(_a0 *models.PVCInfo, _a1 error) *KubeClientMock_CreatePersistentVolumeClaim_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KubeClientMock_CreatePersistentVolumeClaim_Call) RunAndReturn(run func(context.Context, string, string, string, map[string]string, string, []v1.PersistentVolumeAccessMode, *string, kubernetes.Interface) (*models.PVCInfo, error)) *KubeClientMock_CreatePersistentVolumeClaim_Call {
	_c.Call.Return(run)
	return _c
}

// CreateVerificationIngress provides a mock function with given fields: ctx, domain, client
func (_m *KubeClientMock) CreateVerificationIngress(ctx context.Context, domain string, client kubernetes.Interface) (*networkingv1.Ingress, string, error) {
	ret := _m.Called(ctx, domain, client)

	if len(ret) == 0 {
		panic("no return value specified for CreateVerificationIngress")
	}

	var r0 *networkingv1.Ingress
	var r1 string
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, kubernetes.Interface) (*networkingv1.Ingress, string, error)); ok {
		return rf(ctx, domain, client)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, kubernetes.Interface) *networkingv1.Ingress); ok {
		r0 = rf(ctx, domain, client)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*networkingv1.Ingress)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, kubernetes.Interface) string); ok {
		r1 = rf(ctx, domain, client)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, kubernetes.Interface) error); ok {
		r2 = rf(ctx, domain, client)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// KubeClientMock_CreateVerificationIngress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateVerificationIngress'
type KubeClientMock_CreateVerificationIngress_Call struct {
	*mock.Call
}

// CreateVerificationIngress is a helper method to define mock.On call
//   - ctx context.Context
//   - domain string
//   - client kubernetes.Interface
func (_e *KubeClientMock_Expecter) CreateVerificationIngress(ctx interface{}, domain interface{}, client interface{}) *KubeClientMock_CreateVerificationIngress_Call {
	return &KubeClientMock_CreateVerificationIngress_Call{Call: _e.mock.On("CreateVerificationIngress", ctx, domain, client)}
}

func (_c *KubeClientMock_CreateVerificationIngress_Call) Run(run func(ctx context.Context, domain string, client kubernetes.Interface)) *KubeClientMock_CreateVerificationIngress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(kubernetes.Interface))
	})
	return _c
}

func (_c *KubeClientMock_CreateVerificationIngress_Call) Return(_a0 *networkingv1.Ingress, _a1 string, _a2 error) *KubeClientMock_CreateVerificationIngress_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *KubeClientMock_CreateVerificationIngress_Call) RunAndReturn(run func(context.Context, string, kubernetes.Interface) (*networkingv1.Ingress, string, error)) *KubeClientMock_CreateVerificationIngress_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteOldVerificationIngresses provides a mock function with given fields: ctx, client
func (_m *KubeClientMock) DeleteOldVerificationIngresses(ctx context.Context, client kubernetes.Interface) error {
	ret := _m.Called(ctx, client)

	if len(ret) == 0 {
		panic("no return value specified for DeleteOldVerificationIngresses")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, kubernetes.Interface) error); ok {
		r0 = rf(ctx, client)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// KubeClientMock_DeleteOldVerificationIngresses_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteOldVerificationIngresses'
type KubeClientMock_DeleteOldVerificationIngresses_Call struct {
	*mock.Call
}

// DeleteOldVerificationIngresses is a helper method to define mock.On call
//   - ctx context.Context
//   - client kubernetes.Interface
func (_e *KubeClientMock_Expecter) DeleteOldVerificationIngresses(ctx interface{}, client interface{}) *KubeClientMock_DeleteOldVerificationIngresses_Call {
	return &KubeClientMock_DeleteOldVerificationIngresses_Call{Call: _e.mock.On("DeleteOldVerificationIngresses", ctx, client)}
}

func (_c *KubeClientMock_DeleteOldVerificationIngresses_Call) Run(run func(ctx context.Context, client kubernetes.Interface)) *KubeClientMock_DeleteOldVerificationIngresses_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(kubernetes.Interface))
	})
	return _c
}

func (_c *KubeClientMock_DeleteOldVerificationIngresses_Call) Return(_a0 error) *KubeClientMock_DeleteOldVerificationIngresses_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *KubeClientMock_DeleteOldVerificationIngresses_Call) RunAndReturn(run func(context.Context, kubernetes.Interface) error) *KubeClientMock_DeleteOldVerificationIngresses_Call {
	_c.Call.Return(run)
	return _c
}

// DeletePersistentVolumeClaim provides a mock function with given fields: ctx, namespace, pvcName, client
func (_m *KubeClientMock) DeletePersistentVolumeClaim(ctx context.Context, namespace string, pvcName string, client kubernetes.Interface) error {
	ret := _m.Called(ctx, namespace, pvcName, client)

	if len(ret) == 0 {
		panic("no return value specified for DeletePersistentVolumeClaim")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, kubernetes.Interface) error); ok {
		r0 = rf(ctx, namespace, pvcName, client)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// KubeClientMock_DeletePersistentVolumeClaim_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeletePersistentVolumeClaim'
type KubeClientMock_DeletePersistentVolumeClaim_Call struct {
	*mock.Call
}

// DeletePersistentVolumeClaim is a helper method to define mock.On call
//   - ctx context.Context
//   - namespace string
//   - pvcName string
//   - client kubernetes.Interface
func (_e *KubeClientMock_Expecter) DeletePersistentVolumeClaim(ctx interface{}, namespace interface{}, pvcName interface{}, client interface{}) *KubeClientMock_DeletePersistentVolumeClaim_Call {
	return &KubeClientMock_DeletePersistentVolumeClaim_Call{Call: _e.mock.On("DeletePersistentVolumeClaim", ctx, namespace, pvcName, client)}
}

func (_c *KubeClientMock_DeletePersistentVolumeClaim_Call) Run(run func(ctx context.Context, namespace string, pvcName string, client kubernetes.Interface)) *KubeClientMock_DeletePersistentVolumeClaim_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(kubernetes.Interface))
	})
	return _c
}

func (_c *KubeClientMock_DeletePersistentVolumeClaim_Call) Return(_a0 error) *KubeClientMock_DeletePersistentVolumeClaim_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *KubeClientMock_DeletePersistentVolumeClaim_Call) RunAndReturn(run func(context.Context, string, string, kubernetes.Interface) error) *KubeClientMock_DeletePersistentVolumeClaim_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteSecret provides a mock function with given fields: ctx, name, namespace, client
func (_m *KubeClientMock) DeleteSecret(ctx context.Context, name string, namespace string, client kubernetes.Interface) error {
	ret := _m.Called(ctx, name, namespace, client)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSecret")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, kubernetes.Interface) error); ok {
		r0 = rf(ctx, name, namespace, client)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// KubeClientMock_DeleteSecret_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteSecret'
type KubeClientMock_DeleteSecret_Call struct {
	*mock.Call
}

// DeleteSecret is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - namespace string
//   - client kubernetes.Interface
func (_e *KubeClientMock_Expecter) DeleteSecret(ctx interface{}, name interface{}, namespace interface{}, client interface{}) *KubeClientMock_DeleteSecret_Call {
	return &KubeClientMock_DeleteSecret_Call{Call: _e.mock.On("DeleteSecret", ctx, name, namespace, client)}
}

func (_c *KubeClientMock_DeleteSecret_Call) Run(run func(ctx context.Context, name string, namespace string, client kubernetes.Interface)) *KubeClientMock_DeleteSecret_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(kubernetes.Interface))
	})
	return _c
}

func (_c *KubeClientMock_DeleteSecret_Call) Return(_a0 error) *KubeClientMock_DeleteSecret_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *KubeClientMock_DeleteSecret_Call) RunAndReturn(run func(context.Context, string, string, kubernetes.Interface) error) *KubeClientMock_DeleteSecret_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteStatefulSetsWithOrphanCascade provides a mock function with given fields: ctx, namespace, labels, client
func (_m *KubeClientMock) DeleteStatefulSetsWithOrphanCascade(ctx context.Context, namespace string, labels map[string]string, client kubernetes.Interface) error {
	ret := _m.Called(ctx, namespace, labels, client)

	if len(ret) == 0 {
		panic("no return value specified for DeleteStatefulSetsWithOrphanCascade")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]string, kubernetes.Interface) error); ok {
		r0 = rf(ctx, namespace, labels, client)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// KubeClientMock_DeleteStatefulSetsWithOrphanCascade_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteStatefulSetsWithOrphanCascade'
type KubeClientMock_DeleteStatefulSetsWithOrphanCascade_Call struct {
	*mock.Call
}

// DeleteStatefulSetsWithOrphanCascade is a helper method to define mock.On call
//   - ctx context.Context
//   - namespace string
//   - labels map[string]string
//   - client kubernetes.Interface
func (_e *KubeClientMock_Expecter) DeleteStatefulSetsWithOrphanCascade(ctx interface{}, namespace interface{}, labels interface{}, client interface{}) *KubeClientMock_DeleteStatefulSetsWithOrphanCascade_Call {
	return &KubeClientMock_DeleteStatefulSetsWithOrphanCascade_Call{Call: _e.mock.On("DeleteStatefulSetsWithOrphanCascade", ctx, namespace, labels, client)}
}

func (_c *KubeClientMock_DeleteStatefulSetsWithOrphanCascade_Call) Run(run func(ctx context.Context, namespace string, labels map[string]string, client kubernetes.Interface)) *KubeClientMock_DeleteStatefulSetsWithOrphanCascade_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(map[string]string), args[3].(kubernetes.Interface))
	})
	return _c
}

func (_c *KubeClientMock_DeleteStatefulSetsWithOrphanCascade_Call) Return(_a0 error) *KubeClientMock_DeleteStatefulSetsWithOrphanCascade_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *KubeClientMock_DeleteStatefulSetsWithOrphanCascade_Call) RunAndReturn(run func(context.Context, string, map[string]string, kubernetes.Interface) error) *KubeClientMock_DeleteStatefulSetsWithOrphanCascade_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteUnbindService provides a mock function with given fields: ctx, namespace, name
func (_m *KubeClientMock) DeleteUnbindService(ctx context.Context, namespace string, name string) error {
	ret := _m.Called(ctx, namespace, name)

	if len(ret) == 0 {
		panic("no return value specified for DeleteUnbindService")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, namespace, name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// KubeClientMock_DeleteUnbindService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteUnbindService'
type KubeClientMock_DeleteUnbindService_Call struct {
	*mock.Call
}

// DeleteUnbindService is a helper method to define mock.On call
//   - ctx context.Context
//   - namespace string
//   - name string
func (_e *KubeClientMock_Expecter) DeleteUnbindService(ctx interface{}, namespace interface{}, name interface{}) *KubeClientMock_DeleteUnbindService_Call {
	return &KubeClientMock_DeleteUnbindService_Call{Call: _e.mock.On("DeleteUnbindService", ctx, namespace, name)}
}

func (_c *KubeClientMock_DeleteUnbindService_Call) Run(run func(ctx context.Context, namespace string, name string)) *KubeClientMock_DeleteUnbindService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *KubeClientMock_DeleteUnbindService_Call) Return(_a0 error) *KubeClientMock_DeleteUnbindService_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *KubeClientMock_DeleteUnbindService_Call) RunAndReturn(run func(context.Context, string, string) error) *KubeClientMock_DeleteUnbindService_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteVerificationIngress provides a mock function with given fields: ctx, ingressName, client
func (_m *KubeClientMock) DeleteVerificationIngress(ctx context.Context, ingressName string, client kubernetes.Interface) error {
	ret := _m.Called(ctx, ingressName, client)

	if len(ret) == 0 {
		panic("no return value specified for DeleteVerificationIngress")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, kubernetes.Interface) error); ok {
		r0 = rf(ctx, ingressName, client)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// KubeClientMock_DeleteVerificationIngress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteVerificationIngress'
type KubeClientMock_DeleteVerificationIngress_Call struct {
	*mock.Call
}

// DeleteVerificationIngress is a helper method to define mock.On call
//   - ctx context.Context
//   - ingressName string
//   - client kubernetes.Interface
func (_e *KubeClientMock_Expecter) DeleteVerificationIngress(ctx interface{}, ingressName interface{}, client interface{}) *KubeClientMock_DeleteVerificationIngress_Call {
	return &KubeClientMock_DeleteVerificationIngress_Call{Call: _e.mock.On("DeleteVerificationIngress", ctx, ingressName, client)}
}

func (_c *KubeClientMock_DeleteVerificationIngress_Call) Run(run func(ctx context.Context, ingressName string, client kubernetes.Interface)) *KubeClientMock_DeleteVerificationIngress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(kubernetes.Interface))
	})
	return _c
}

func (_c *KubeClientMock_DeleteVerificationIngress_Call) Return(_a0 error) *KubeClientMock_DeleteVerificationIngress_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *KubeClientMock_DeleteVerificationIngress_Call) RunAndReturn(run func(context.Context, string, kubernetes.Interface) error) *KubeClientMock_DeleteVerificationIngress_Call {
	_c.Call.Return(run)
	return _c
}

// DeployUnbindService provides a mock function with given fields: ctx, service
func (_m *KubeClientMock) DeployUnbindService(ctx context.Context, service *apiv1.Service) (*unstructured.Unstructured, *apiv1.Service, error) {
	ret := _m.Called(ctx, service)

	if len(ret) == 0 {
		panic("no return value specified for DeployUnbindService")
	}

	var r0 *unstructured.Unstructured
	var r1 *apiv1.Service
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, *apiv1.Service) (*unstructured.Unstructured, *apiv1.Service, error)); ok {
		return rf(ctx, service)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *apiv1.Service) *unstructured.Unstructured); ok {
		r0 = rf(ctx, service)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*unstructured.Unstructured)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *apiv1.Service) *apiv1.Service); ok {
		r1 = rf(ctx, service)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*apiv1.Service)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, *apiv1.Service) error); ok {
		r2 = rf(ctx, service)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// KubeClientMock_DeployUnbindService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeployUnbindService'
type KubeClientMock_DeployUnbindService_Call struct {
	*mock.Call
}

// DeployUnbindService is a helper method to define mock.On call
//   - ctx context.Context
//   - service *apiv1.Service
func (_e *KubeClientMock_Expecter) DeployUnbindService(ctx interface{}, service interface{}) *KubeClientMock_DeployUnbindService_Call {
	return &KubeClientMock_DeployUnbindService_Call{Call: _e.mock.On("DeployUnbindService", ctx, service)}
}

func (_c *KubeClientMock_DeployUnbindService_Call) Run(run func(ctx context.Context, service *apiv1.Service)) *KubeClientMock_DeployUnbindService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*apiv1.Service))
	})
	return _c
}

func (_c *KubeClientMock_DeployUnbindService_Call) Return(_a0 *unstructured.Unstructured, _a1 *apiv1.Service, _a2 error) *KubeClientMock_DeployUnbindService_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *KubeClientMock_DeployUnbindService_Call) RunAndReturn(run func(context.Context, *apiv1.Service) (*unstructured.Unstructured, *apiv1.Service, error)) *KubeClientMock_DeployUnbindService_Call {
	_c.Call.Return(run)
	return _c
}

// DiscoverEndpointsByLabels provides a mock function with given fields: ctx, namespace, labels, checkDNS, client
func (_m *KubeClientMock) DiscoverEndpointsByLabels(ctx context.Context, namespace string, labels map[string]string, checkDNS bool, client kubernetes.Interface) (*models.EndpointDiscovery, error) {
	ret := _m.Called(ctx, namespace, labels, checkDNS, client)

	if len(ret) == 0 {
		panic("no return value specified for DiscoverEndpointsByLabels")
	}

	var r0 *models.EndpointDiscovery
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]string, bool, kubernetes.Interface) (*models.EndpointDiscovery, error)); ok {
		return rf(ctx, namespace, labels, checkDNS, client)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]string, bool, kubernetes.Interface) *models.EndpointDiscovery); ok {
		r0 = rf(ctx, namespace, labels, checkDNS, client)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.EndpointDiscovery)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, map[string]string, bool, kubernetes.Interface) error); ok {
		r1 = rf(ctx, namespace, labels, checkDNS, client)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KubeClientMock_DiscoverEndpointsByLabels_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DiscoverEndpointsByLabels'
type KubeClientMock_DiscoverEndpointsByLabels_Call struct {
	*mock.Call
}

// DiscoverEndpointsByLabels is a helper method to define mock.On call
//   - ctx context.Context
//   - namespace string
//   - labels map[string]string
//   - checkDNS bool
//   - client kubernetes.Interface
func (_e *KubeClientMock_Expecter) DiscoverEndpointsByLabels(ctx interface{}, namespace interface{}, labels interface{}, checkDNS interface{}, client interface{}) *KubeClientMock_DiscoverEndpointsByLabels_Call {
	return &KubeClientMock_DiscoverEndpointsByLabels_Call{Call: _e.mock.On("DiscoverEndpointsByLabels", ctx, namespace, labels, checkDNS, client)}
}

func (_c *KubeClientMock_DiscoverEndpointsByLabels_Call) Run(run func(ctx context.Context, namespace string, labels map[string]string, checkDNS bool, client kubernetes.Interface)) *KubeClientMock_DiscoverEndpointsByLabels_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(map[string]string), args[3].(bool), args[4].(kubernetes.Interface))
	})
	return _c
}

func (_c *KubeClientMock_DiscoverEndpointsByLabels_Call) Return(_a0 *models.EndpointDiscovery, _a1 error) *KubeClientMock_DiscoverEndpointsByLabels_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KubeClientMock_DiscoverEndpointsByLabels_Call) RunAndReturn(run func(context.Context, string, map[string]string, bool, kubernetes.Interface) (*models.EndpointDiscovery, error)) *KubeClientMock_DiscoverEndpointsByLabels_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllSecrets provides a mock function with given fields: ctx, teamID, teamSecret, projectID, projectSecret, environmentID, environmentSecret, serviceSecrets, client, namespace
func (_m *KubeClientMock) GetAllSecrets(ctx context.Context, teamID uuid.UUID, teamSecret string, projectID uuid.UUID, projectSecret string, environmentID uuid.UUID, environmentSecret string, serviceSecrets map[uuid.UUID]string, client kubernetes.Interface, namespace string) ([]models.SecretData, error) {
	ret := _m.Called(ctx, teamID, teamSecret, projectID, projectSecret, environmentID, environmentSecret, serviceSecrets, client, namespace)

	if len(ret) == 0 {
		panic("no return value specified for GetAllSecrets")
	}

	var r0 []models.SecretData
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, uuid.UUID, string, uuid.UUID, string, map[uuid.UUID]string, kubernetes.Interface, string) ([]models.SecretData, error)); ok {
		return rf(ctx, teamID, teamSecret, projectID, projectSecret, environmentID, environmentSecret, serviceSecrets, client, namespace)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, uuid.UUID, string, uuid.UUID, string, map[uuid.UUID]string, kubernetes.Interface, string) []models.SecretData); ok {
		r0 = rf(ctx, teamID, teamSecret, projectID, projectSecret, environmentID, environmentSecret, serviceSecrets, client, namespace)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.SecretData)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, string, uuid.UUID, string, uuid.UUID, string, map[uuid.UUID]string, kubernetes.Interface, string) error); ok {
		r1 = rf(ctx, teamID, teamSecret, projectID, projectSecret, environmentID, environmentSecret, serviceSecrets, client, namespace)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KubeClientMock_GetAllSecrets_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllSecrets'
type KubeClientMock_GetAllSecrets_Call struct {
	*mock.Call
}

// GetAllSecrets is a helper method to define mock.On call
//   - ctx context.Context
//   - teamID uuid.UUID
//   - teamSecret string
//   - projectID uuid.UUID
//   - projectSecret string
//   - environmentID uuid.UUID
//   - environmentSecret string
//   - serviceSecrets map[uuid.UUID]string
//   - client kubernetes.Interface
//   - namespace string
func (_e *KubeClientMock_Expecter) GetAllSecrets(ctx interface{}, teamID interface{}, teamSecret interface{}, projectID interface{}, projectSecret interface{}, environmentID interface{}, environmentSecret interface{}, serviceSecrets interface{}, client interface{}, namespace interface{}) *KubeClientMock_GetAllSecrets_Call {
	return &KubeClientMock_GetAllSecrets_Call{Call: _e.mock.On("GetAllSecrets", ctx, teamID, teamSecret, projectID, projectSecret, environmentID, environmentSecret, serviceSecrets, client, namespace)}
}

func (_c *KubeClientMock_GetAllSecrets_Call) Run(run func(ctx context.Context, teamID uuid.UUID, teamSecret string, projectID uuid.UUID, projectSecret string, environmentID uuid.UUID, environmentSecret string, serviceSecrets map[uuid.UUID]string, client kubernetes.Interface, namespace string)) *KubeClientMock_GetAllSecrets_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(string), args[3].(uuid.UUID), args[4].(string), args[5].(uuid.UUID), args[6].(string), args[7].(map[uuid.UUID]string), args[8].(kubernetes.Interface), args[9].(string))
	})
	return _c
}

func (_c *KubeClientMock_GetAllSecrets_Call) Return(_a0 []models.SecretData, _a1 error) *KubeClientMock_GetAllSecrets_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KubeClientMock_GetAllSecrets_Call) RunAndReturn(run func(context.Context, uuid.UUID, string, uuid.UUID, string, uuid.UUID, string, map[uuid.UUID]string, kubernetes.Interface, string) ([]models.SecretData, error)) *KubeClientMock_GetAllSecrets_Call {
	_c.Call.Return(run)
	return _c
}

// GetExpectedInstances provides a mock function with given fields: ctx, namespace, podName, client
func (_m *KubeClientMock) GetExpectedInstances(ctx context.Context, namespace string, podName string, client kubernetes.Interface) (int, error) {
	ret := _m.Called(ctx, namespace, podName, client)

	if len(ret) == 0 {
		panic("no return value specified for GetExpectedInstances")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, kubernetes.Interface) (int, error)); ok {
		return rf(ctx, namespace, podName, client)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, kubernetes.Interface) int); ok {
		r0 = rf(ctx, namespace, podName, client)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, kubernetes.Interface) error); ok {
		r1 = rf(ctx, namespace, podName, client)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KubeClientMock_GetExpectedInstances_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetExpectedInstances'
type KubeClientMock_GetExpectedInstances_Call struct {
	*mock.Call
}

// GetExpectedInstances is a helper method to define mock.On call
//   - ctx context.Context
//   - namespace string
//   - podName string
//   - client kubernetes.Interface
func (_e *KubeClientMock_Expecter) GetExpectedInstances(ctx interface{}, namespace interface{}, podName interface{}, client interface{}) *KubeClientMock_GetExpectedInstances_Call {
	return &KubeClientMock_GetExpectedInstances_Call{Call: _e.mock.On("GetExpectedInstances", ctx, namespace, podName, client)}
}

func (_c *KubeClientMock_GetExpectedInstances_Call) Run(run func(ctx context.Context, namespace string, podName string, client kubernetes.Interface)) *KubeClientMock_GetExpectedInstances_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(kubernetes.Interface))
	})
	return _c
}

func (_c *KubeClientMock_GetExpectedInstances_Call) Return(_a0 int, _a1 error) *KubeClientMock_GetExpectedInstances_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KubeClientMock_GetExpectedInstances_Call) RunAndReturn(run func(context.Context, string, string, kubernetes.Interface) (int, error)) *KubeClientMock_GetExpectedInstances_Call {
	_c.Call.Return(run)
	return _c
}

// GetIngressNginxIP provides a mock function with given fields: ctx
func (_m *KubeClientMock) GetIngressNginxIP(ctx context.Context) (*k8s.LoadBalancerAddresses, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetIngressNginxIP")
	}

	var r0 *k8s.LoadBalancerAddresses
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*k8s.LoadBalancerAddresses, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *k8s.LoadBalancerAddresses); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*k8s.LoadBalancerAddresses)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KubeClientMock_GetIngressNginxIP_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetIngressNginxIP'
type KubeClientMock_GetIngressNginxIP_Call struct {
	*mock.Call
}

// GetIngressNginxIP is a helper method to define mock.On call
//   - ctx context.Context
func (_e *KubeClientMock_Expecter) GetIngressNginxIP(ctx interface{}) *KubeClientMock_GetIngressNginxIP_Call {
	return &KubeClientMock_GetIngressNginxIP_Call{Call: _e.mock.On("GetIngressNginxIP", ctx)}
}

func (_c *KubeClientMock_GetIngressNginxIP_Call) Run(run func(ctx context.Context)) *KubeClientMock_GetIngressNginxIP_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *KubeClientMock_GetIngressNginxIP_Call) Return(_a0 *k8s.LoadBalancerAddresses, _a1 error) *KubeClientMock_GetIngressNginxIP_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KubeClientMock_GetIngressNginxIP_Call) RunAndReturn(run func(context.Context) (*k8s.LoadBalancerAddresses, error)) *KubeClientMock_GetIngressNginxIP_Call {
	_c.Call.Return(run)
	return _c
}

// GetInternalClient provides a mock function with no fields
func (_m *KubeClientMock) GetInternalClient() kubernetes.Interface {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetInternalClient")
	}

	var r0 kubernetes.Interface
	if rf, ok := ret.Get(0).(func() kubernetes.Interface); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(kubernetes.Interface)
		}
	}

	return r0
}

// KubeClientMock_GetInternalClient_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetInternalClient'
type KubeClientMock_GetInternalClient_Call struct {
	*mock.Call
}

// GetInternalClient is a helper method to define mock.On call
func (_e *KubeClientMock_Expecter) GetInternalClient() *KubeClientMock_GetInternalClient_Call {
	return &KubeClientMock_GetInternalClient_Call{Call: _e.mock.On("GetInternalClient")}
}

func (_c *KubeClientMock_GetInternalClient_Call) Run(run func()) *KubeClientMock_GetInternalClient_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *KubeClientMock_GetInternalClient_Call) Return(_a0 kubernetes.Interface) *KubeClientMock_GetInternalClient_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *KubeClientMock_GetInternalClient_Call) RunAndReturn(run func() kubernetes.Interface) *KubeClientMock_GetInternalClient_Call {
	_c.Call.Return(run)
	return _c
}

// GetJobStatus provides a mock function with given fields: ctx, jobName
func (_m *KubeClientMock) GetJobStatus(ctx context.Context, jobName string) (k8s.JobStatus, error) {
	ret := _m.Called(ctx, jobName)

	if len(ret) == 0 {
		panic("no return value specified for GetJobStatus")
	}

	var r0 k8s.JobStatus
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (k8s.JobStatus, error)); ok {
		return rf(ctx, jobName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) k8s.JobStatus); ok {
		r0 = rf(ctx, jobName)
	} else {
		r0 = ret.Get(0).(k8s.JobStatus)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, jobName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KubeClientMock_GetJobStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetJobStatus'
type KubeClientMock_GetJobStatus_Call struct {
	*mock.Call
}

// GetJobStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - jobName string
func (_e *KubeClientMock_Expecter) GetJobStatus(ctx interface{}, jobName interface{}) *KubeClientMock_GetJobStatus_Call {
	return &KubeClientMock_GetJobStatus_Call{Call: _e.mock.On("GetJobStatus", ctx, jobName)}
}

func (_c *KubeClientMock_GetJobStatus_Call) Run(run func(ctx context.Context, jobName string)) *KubeClientMock_GetJobStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *KubeClientMock_GetJobStatus_Call) Return(_a0 k8s.JobStatus, _a1 error) *KubeClientMock_GetJobStatus_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KubeClientMock_GetJobStatus_Call) RunAndReturn(run func(context.Context, string) (k8s.JobStatus, error)) *KubeClientMock_GetJobStatus_Call {
	_c.Call.Return(run)
	return _c
}

// GetLoadBalancerIPs provides a mock function with given fields: ctx, labelSelector
func (_m *KubeClientMock) GetLoadBalancerIPs(ctx context.Context, labelSelector string) ([]k8s.LoadBalancerAddresses, error) {
	ret := _m.Called(ctx, labelSelector)

	if len(ret) == 0 {
		panic("no return value specified for GetLoadBalancerIPs")
	}

	var r0 []k8s.LoadBalancerAddresses
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]k8s.LoadBalancerAddresses, error)); ok {
		return rf(ctx, labelSelector)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []k8s.LoadBalancerAddresses); ok {
		r0 = rf(ctx, labelSelector)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]k8s.LoadBalancerAddresses)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, labelSelector)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KubeClientMock_GetLoadBalancerIPs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLoadBalancerIPs'
type KubeClientMock_GetLoadBalancerIPs_Call struct {
	*mock.Call
}

// GetLoadBalancerIPs is a helper method to define mock.On call
//   - ctx context.Context
//   - labelSelector string
func (_e *KubeClientMock_Expecter) GetLoadBalancerIPs(ctx interface{}, labelSelector interface{}) *KubeClientMock_GetLoadBalancerIPs_Call {
	return &KubeClientMock_GetLoadBalancerIPs_Call{Call: _e.mock.On("GetLoadBalancerIPs", ctx, labelSelector)}
}

func (_c *KubeClientMock_GetLoadBalancerIPs_Call) Run(run func(ctx context.Context, labelSelector string)) *KubeClientMock_GetLoadBalancerIPs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *KubeClientMock_GetLoadBalancerIPs_Call) Return(_a0 []k8s.LoadBalancerAddresses, _a1 error) *KubeClientMock_GetLoadBalancerIPs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KubeClientMock_GetLoadBalancerIPs_Call) RunAndReturn(run func(context.Context, string) ([]k8s.LoadBalancerAddresses, error)) *KubeClientMock_GetLoadBalancerIPs_Call {
	_c.Call.Return(run)
	return _c
}

// GetNamespaces provides a mock function with given fields: ctx, namespaceNames, bearerToken
func (_m *KubeClientMock) GetNamespaces(ctx context.Context, namespaceNames []string, bearerToken string) ([]*v1.Namespace, error) {
	ret := _m.Called(ctx, namespaceNames, bearerToken)

	if len(ret) == 0 {
		panic("no return value specified for GetNamespaces")
	}

	var r0 []*v1.Namespace
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string, string) ([]*v1.Namespace, error)); ok {
		return rf(ctx, namespaceNames, bearerToken)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string, string) []*v1.Namespace); ok {
		r0 = rf(ctx, namespaceNames, bearerToken)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*v1.Namespace)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string, string) error); ok {
		r1 = rf(ctx, namespaceNames, bearerToken)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KubeClientMock_GetNamespaces_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNamespaces'
type KubeClientMock_GetNamespaces_Call struct {
	*mock.Call
}

// GetNamespaces is a helper method to define mock.On call
//   - ctx context.Context
//   - namespaceNames []string
//   - bearerToken string
func (_e *KubeClientMock_Expecter) GetNamespaces(ctx interface{}, namespaceNames interface{}, bearerToken interface{}) *KubeClientMock_GetNamespaces_Call {
	return &KubeClientMock_GetNamespaces_Call{Call: _e.mock.On("GetNamespaces", ctx, namespaceNames, bearerToken)}
}

func (_c *KubeClientMock_GetNamespaces_Call) Run(run func(ctx context.Context, namespaceNames []string, bearerToken string)) *KubeClientMock_GetNamespaces_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]string), args[2].(string))
	})
	return _c
}

func (_c *KubeClientMock_GetNamespaces_Call) Return(_a0 []*v1.Namespace, _a1 error) *KubeClientMock_GetNamespaces_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KubeClientMock_GetNamespaces_Call) RunAndReturn(run func(context.Context, []string, string) ([]*v1.Namespace, error)) *KubeClientMock_GetNamespaces_Call {
	_c.Call.Return(run)
	return _c
}

// GetOrCreateSecret provides a mock function with given fields: ctx, name, namespace, client
func (_m *KubeClientMock) GetOrCreateSecret(ctx context.Context, name string, namespace string, client kubernetes.Interface) (*v1.Secret, bool, error) {
	ret := _m.Called(ctx, name, namespace, client)

	if len(ret) == 0 {
		panic("no return value specified for GetOrCreateSecret")
	}

	var r0 *v1.Secret
	var r1 bool
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, kubernetes.Interface) (*v1.Secret, bool, error)); ok {
		return rf(ctx, name, namespace, client)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, kubernetes.Interface) *v1.Secret); ok {
		r0 = rf(ctx, name, namespace, client)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1.Secret)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, kubernetes.Interface) bool); ok {
		r1 = rf(ctx, name, namespace, client)
	} else {
		r1 = ret.Get(1).(bool)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, kubernetes.Interface) error); ok {
		r2 = rf(ctx, name, namespace, client)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// KubeClientMock_GetOrCreateSecret_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetOrCreateSecret'
type KubeClientMock_GetOrCreateSecret_Call struct {
	*mock.Call
}

// GetOrCreateSecret is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - namespace string
//   - client kubernetes.Interface
func (_e *KubeClientMock_Expecter) GetOrCreateSecret(ctx interface{}, name interface{}, namespace interface{}, client interface{}) *KubeClientMock_GetOrCreateSecret_Call {
	return &KubeClientMock_GetOrCreateSecret_Call{Call: _e.mock.On("GetOrCreateSecret", ctx, name, namespace, client)}
}

func (_c *KubeClientMock_GetOrCreateSecret_Call) Run(run func(ctx context.Context, name string, namespace string, client kubernetes.Interface)) *KubeClientMock_GetOrCreateSecret_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(kubernetes.Interface))
	})
	return _c
}

func (_c *KubeClientMock_GetOrCreateSecret_Call) Return(_a0 *v1.Secret, _a1 bool, _a2 error) *KubeClientMock_GetOrCreateSecret_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *KubeClientMock_GetOrCreateSecret_Call) RunAndReturn(run func(context.Context, string, string, kubernetes.Interface) (*v1.Secret, bool, error)) *KubeClientMock_GetOrCreateSecret_Call {
	_c.Call.Return(run)
	return _c
}

// GetPersistentVolumeClaim provides a mock function with given fields: ctx, namespace, pvcName, client
func (_m *KubeClientMock) GetPersistentVolumeClaim(ctx context.Context, namespace string, pvcName string, client kubernetes.Interface) (*models.PVCInfo, error) {
	ret := _m.Called(ctx, namespace, pvcName, client)

	if len(ret) == 0 {
		panic("no return value specified for GetPersistentVolumeClaim")
	}

	var r0 *models.PVCInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, kubernetes.Interface) (*models.PVCInfo, error)); ok {
		return rf(ctx, namespace, pvcName, client)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, kubernetes.Interface) *models.PVCInfo); ok {
		r0 = rf(ctx, namespace, pvcName, client)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.PVCInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, kubernetes.Interface) error); ok {
		r1 = rf(ctx, namespace, pvcName, client)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KubeClientMock_GetPersistentVolumeClaim_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPersistentVolumeClaim'
type KubeClientMock_GetPersistentVolumeClaim_Call struct {
	*mock.Call
}

// GetPersistentVolumeClaim is a helper method to define mock.On call
//   - ctx context.Context
//   - namespace string
//   - pvcName string
//   - client kubernetes.Interface
func (_e *KubeClientMock_Expecter) GetPersistentVolumeClaim(ctx interface{}, namespace interface{}, pvcName interface{}, client interface{}) *KubeClientMock_GetPersistentVolumeClaim_Call {
	return &KubeClientMock_GetPersistentVolumeClaim_Call{Call: _e.mock.On("GetPersistentVolumeClaim", ctx, namespace, pvcName, client)}
}

func (_c *KubeClientMock_GetPersistentVolumeClaim_Call) Run(run func(ctx context.Context, namespace string, pvcName string, client kubernetes.Interface)) *KubeClientMock_GetPersistentVolumeClaim_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(kubernetes.Interface))
	})
	return _c
}

func (_c *KubeClientMock_GetPersistentVolumeClaim_Call) Return(_a0 *models.PVCInfo, _a1 error) *KubeClientMock_GetPersistentVolumeClaim_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KubeClientMock_GetPersistentVolumeClaim_Call) RunAndReturn(run func(context.Context, string, string, kubernetes.Interface) (*models.PVCInfo, error)) *KubeClientMock_GetPersistentVolumeClaim_Call {
	_c.Call.Return(run)
	return _c
}

// GetPodContainerStatusByLabels provides a mock function with given fields: ctx, namespace, labels, client
func (_m *KubeClientMock) GetPodContainerStatusByLabels(ctx context.Context, namespace string, labels map[string]string, client kubernetes.Interface) ([]k8s.PodContainerStatus, error) {
	ret := _m.Called(ctx, namespace, labels, client)

	if len(ret) == 0 {
		panic("no return value specified for GetPodContainerStatusByLabels")
	}

	var r0 []k8s.PodContainerStatus
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]string, kubernetes.Interface) ([]k8s.PodContainerStatus, error)); ok {
		return rf(ctx, namespace, labels, client)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]string, kubernetes.Interface) []k8s.PodContainerStatus); ok {
		r0 = rf(ctx, namespace, labels, client)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]k8s.PodContainerStatus)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, map[string]string, kubernetes.Interface) error); ok {
		r1 = rf(ctx, namespace, labels, client)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KubeClientMock_GetPodContainerStatusByLabels_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPodContainerStatusByLabels'
type KubeClientMock_GetPodContainerStatusByLabels_Call struct {
	*mock.Call
}

// GetPodContainerStatusByLabels is a helper method to define mock.On call
//   - ctx context.Context
//   - namespace string
//   - labels map[string]string
//   - client kubernetes.Interface
func (_e *KubeClientMock_Expecter) GetPodContainerStatusByLabels(ctx interface{}, namespace interface{}, labels interface{}, client interface{}) *KubeClientMock_GetPodContainerStatusByLabels_Call {
	return &KubeClientMock_GetPodContainerStatusByLabels_Call{Call: _e.mock.On("GetPodContainerStatusByLabels", ctx, namespace, labels, client)}
}

func (_c *KubeClientMock_GetPodContainerStatusByLabels_Call) Run(run func(ctx context.Context, namespace string, labels map[string]string, client kubernetes.Interface)) *KubeClientMock_GetPodContainerStatusByLabels_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(map[string]string), args[3].(kubernetes.Interface))
	})
	return _c
}

func (_c *KubeClientMock_GetPodContainerStatusByLabels_Call) Return(_a0 []k8s.PodContainerStatus, _a1 error) *KubeClientMock_GetPodContainerStatusByLabels_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KubeClientMock_GetPodContainerStatusByLabels_Call) RunAndReturn(run func(context.Context, string, map[string]string, kubernetes.Interface) ([]k8s.PodContainerStatus, error)) *KubeClientMock_GetPodContainerStatusByLabels_Call {
	_c.Call.Return(run)
	return _c
}

// GetPodContainerStatusByLabelsWithOptions provides a mock function with given fields: ctx, namespace, labels, client, options
func (_m *KubeClientMock) GetPodContainerStatusByLabelsWithOptions(ctx context.Context, namespace string, labels map[string]string, client kubernetes.Interface, options k8s.PodStatusOptions) ([]k8s.PodContainerStatus, error) {
	ret := _m.Called(ctx, namespace, labels, client, options)

	if len(ret) == 0 {
		panic("no return value specified for GetPodContainerStatusByLabelsWithOptions")
	}

	var r0 []k8s.PodContainerStatus
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]string, kubernetes.Interface, k8s.PodStatusOptions) ([]k8s.PodContainerStatus, error)); ok {
		return rf(ctx, namespace, labels, client, options)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]string, kubernetes.Interface, k8s.PodStatusOptions) []k8s.PodContainerStatus); ok {
		r0 = rf(ctx, namespace, labels, client, options)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]k8s.PodContainerStatus)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, map[string]string, kubernetes.Interface, k8s.PodStatusOptions) error); ok {
		r1 = rf(ctx, namespace, labels, client, options)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KubeClientMock_GetPodContainerStatusByLabelsWithOptions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPodContainerStatusByLabelsWithOptions'
type KubeClientMock_GetPodContainerStatusByLabelsWithOptions_Call struct {
	*mock.Call
}

// GetPodContainerStatusByLabelsWithOptions is a helper method to define mock.On call
//   - ctx context.Context
//   - namespace string
//   - labels map[string]string
//   - client kubernetes.Interface
//   - options k8s.PodStatusOptions
func (_e *KubeClientMock_Expecter) GetPodContainerStatusByLabelsWithOptions(ctx interface{}, namespace interface{}, labels interface{}, client interface{}, options interface{}) *KubeClientMock_GetPodContainerStatusByLabelsWithOptions_Call {
	return &KubeClientMock_GetPodContainerStatusByLabelsWithOptions_Call{Call: _e.mock.On("GetPodContainerStatusByLabelsWithOptions", ctx, namespace, labels, client, options)}
}

func (_c *KubeClientMock_GetPodContainerStatusByLabelsWithOptions_Call) Run(run func(ctx context.Context, namespace string, labels map[string]string, client kubernetes.Interface, options k8s.PodStatusOptions)) *KubeClientMock_GetPodContainerStatusByLabelsWithOptions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(map[string]string), args[3].(kubernetes.Interface), args[4].(k8s.PodStatusOptions))
	})
	return _c
}

func (_c *KubeClientMock_GetPodContainerStatusByLabelsWithOptions_Call) Return(_a0 []k8s.PodContainerStatus, _a1 error) *KubeClientMock_GetPodContainerStatusByLabelsWithOptions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KubeClientMock_GetPodContainerStatusByLabelsWithOptions_Call) RunAndReturn(run func(context.Context, string, map[string]string, kubernetes.Interface, k8s.PodStatusOptions) ([]k8s.PodContainerStatus, error)) *KubeClientMock_GetPodContainerStatusByLabelsWithOptions_Call {
	_c.Call.Return(run)
	return _c
}

// GetPodsByLabels provides a mock function with given fields: ctx, namespace, labels, client
func (_m *KubeClientMock) GetPodsByLabels(ctx context.Context, namespace string, labels map[string]string, client kubernetes.Interface) (*v1.PodList, error) {
	ret := _m.Called(ctx, namespace, labels, client)

	if len(ret) == 0 {
		panic("no return value specified for GetPodsByLabels")
	}

	var r0 *v1.PodList
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]string, kubernetes.Interface) (*v1.PodList, error)); ok {
		return rf(ctx, namespace, labels, client)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]string, kubernetes.Interface) *v1.PodList); ok {
		r0 = rf(ctx, namespace, labels, client)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1.PodList)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, map[string]string, kubernetes.Interface) error); ok {
		r1 = rf(ctx, namespace, labels, client)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KubeClientMock_GetPodsByLabels_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPodsByLabels'
type KubeClientMock_GetPodsByLabels_Call struct {
	*mock.Call
}

// GetPodsByLabels is a helper method to define mock.On call
//   - ctx context.Context
//   - namespace string
//   - labels map[string]string
//   - client kubernetes.Interface
func (_e *KubeClientMock_Expecter) GetPodsByLabels(ctx interface{}, namespace interface{}, labels interface{}, client interface{}) *KubeClientMock_GetPodsByLabels_Call {
	return &KubeClientMock_GetPodsByLabels_Call{Call: _e.mock.On("GetPodsByLabels", ctx, namespace, labels, client)}
}

func (_c *KubeClientMock_GetPodsByLabels_Call) Run(run func(ctx context.Context, namespace string, labels map[string]string, client kubernetes.Interface)) *KubeClientMock_GetPodsByLabels_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(map[string]string), args[3].(kubernetes.Interface))
	})
	return _c
}

func (_c *KubeClientMock_GetPodsByLabels_Call) Return(_a0 *v1.PodList, _a1 error) *KubeClientMock_GetPodsByLabels_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KubeClientMock_GetPodsByLabels_Call) RunAndReturn(run func(context.Context, string, map[string]string, kubernetes.Interface) (*v1.PodList, error)) *KubeClientMock_GetPodsByLabels_Call {
	_c.Call.Return(run)
	return _c
}

// GetPodsUsingPVC provides a mock function with given fields: ctx, namespace, pvcName, client
func (_m *KubeClientMock) GetPodsUsingPVC(ctx context.Context, namespace string, pvcName string, client kubernetes.Interface) ([]v1.Pod, error) {
	ret := _m.Called(ctx, namespace, pvcName, client)

	if len(ret) == 0 {
		panic("no return value specified for GetPodsUsingPVC")
	}

	var r0 []v1.Pod
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, kubernetes.Interface) ([]v1.Pod, error)); ok {
		return rf(ctx, namespace, pvcName, client)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, kubernetes.Interface) []v1.Pod); ok {
		r0 = rf(ctx, namespace, pvcName, client)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]v1.Pod)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, kubernetes.Interface) error); ok {
		r1 = rf(ctx, namespace, pvcName, client)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KubeClientMock_GetPodsUsingPVC_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPodsUsingPVC'
type KubeClientMock_GetPodsUsingPVC_Call struct {
	*mock.Call
}

// GetPodsUsingPVC is a helper method to define mock.On call
//   - ctx context.Context
//   - namespace string
//   - pvcName string
//   - client kubernetes.Interface
func (_e *KubeClientMock_Expecter) GetPodsUsingPVC(ctx interface{}, namespace interface{}, pvcName interface{}, client interface{}) *KubeClientMock_GetPodsUsingPVC_Call {
	return &KubeClientMock_GetPodsUsingPVC_Call{Call: _e.mock.On("GetPodsUsingPVC", ctx, namespace, pvcName, client)}
}

func (_c *KubeClientMock_GetPodsUsingPVC_Call) Run(run func(ctx context.Context, namespace string, pvcName string, client kubernetes.Interface)) *KubeClientMock_GetPodsUsingPVC_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(kubernetes.Interface))
	})
	return _c
}

func (_c *KubeClientMock_GetPodsUsingPVC_Call) Return(_a0 []v1.Pod, _a1 error) *KubeClientMock_GetPodsUsingPVC_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KubeClientMock_GetPodsUsingPVC_Call) RunAndReturn(run func(context.Context, string, string, kubernetes.Interface) ([]v1.Pod, error)) *KubeClientMock_GetPodsUsingPVC_Call {
	_c.Call.Return(run)
	return _c
}

// GetSecret provides a mock function with given fields: ctx, name, namespace, client
func (_m *KubeClientMock) GetSecret(ctx context.Context, name string, namespace string, client kubernetes.Interface) (*v1.Secret, error) {
	ret := _m.Called(ctx, name, namespace, client)

	if len(ret) == 0 {
		panic("no return value specified for GetSecret")
	}

	var r0 *v1.Secret
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, kubernetes.Interface) (*v1.Secret, error)); ok {
		return rf(ctx, name, namespace, client)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, kubernetes.Interface) *v1.Secret); ok {
		r0 = rf(ctx, name, namespace, client)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1.Secret)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, kubernetes.Interface) error); ok {
		r1 = rf(ctx, name, namespace, client)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KubeClientMock_GetSecret_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSecret'
type KubeClientMock_GetSecret_Call struct {
	*mock.Call
}

// GetSecret is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - namespace string
//   - client kubernetes.Interface
func (_e *KubeClientMock_Expecter) GetSecret(ctx interface{}, name interface{}, namespace interface{}, client interface{}) *KubeClientMock_GetSecret_Call {
	return &KubeClientMock_GetSecret_Call{Call: _e.mock.On("GetSecret", ctx, name, namespace, client)}
}

func (_c *KubeClientMock_GetSecret_Call) Run(run func(ctx context.Context, name string, namespace string, client kubernetes.Interface)) *KubeClientMock_GetSecret_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(kubernetes.Interface))
	})
	return _c
}

func (_c *KubeClientMock_GetSecret_Call) Return(_a0 *v1.Secret, _a1 error) *KubeClientMock_GetSecret_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KubeClientMock_GetSecret_Call) RunAndReturn(run func(context.Context, string, string, kubernetes.Interface) (*v1.Secret, error)) *KubeClientMock_GetSecret_Call {
	_c.Call.Return(run)
	return _c
}

// GetSecretMap provides a mock function with given fields: ctx, name, namespace, client
func (_m *KubeClientMock) GetSecretMap(ctx context.Context, name string, namespace string, client kubernetes.Interface) (map[string][]byte, error) {
	ret := _m.Called(ctx, name, namespace, client)

	if len(ret) == 0 {
		panic("no return value specified for GetSecretMap")
	}

	var r0 map[string][]byte
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, kubernetes.Interface) (map[string][]byte, error)); ok {
		return rf(ctx, name, namespace, client)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, kubernetes.Interface) map[string][]byte); ok {
		r0 = rf(ctx, name, namespace, client)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string][]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, kubernetes.Interface) error); ok {
		r1 = rf(ctx, name, namespace, client)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KubeClientMock_GetSecretMap_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSecretMap'
type KubeClientMock_GetSecretMap_Call struct {
	*mock.Call
}

// GetSecretMap is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - namespace string
//   - client kubernetes.Interface
func (_e *KubeClientMock_Expecter) GetSecretMap(ctx interface{}, name interface{}, namespace interface{}, client interface{}) *KubeClientMock_GetSecretMap_Call {
	return &KubeClientMock_GetSecretMap_Call{Call: _e.mock.On("GetSecretMap", ctx, name, namespace, client)}
}

func (_c *KubeClientMock_GetSecretMap_Call) Run(run func(ctx context.Context, name string, namespace string, client kubernetes.Interface)) *KubeClientMock_GetSecretMap_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(kubernetes.Interface))
	})
	return _c
}

func (_c *KubeClientMock_GetSecretMap_Call) Return(_a0 map[string][]byte, _a1 error) *KubeClientMock_GetSecretMap_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KubeClientMock_GetSecretMap_Call) RunAndReturn(run func(context.Context, string, string, kubernetes.Interface) (map[string][]byte, error)) *KubeClientMock_GetSecretMap_Call {
	_c.Call.Return(run)
	return _c
}

// GetSecretValue provides a mock function with given fields: ctx, name, namespace, key, client
func (_m *KubeClientMock) GetSecretValue(ctx context.Context, name string, namespace string, key string, client kubernetes.Interface) ([]byte, error) {
	ret := _m.Called(ctx, name, namespace, key, client)

	if len(ret) == 0 {
		panic("no return value specified for GetSecretValue")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, kubernetes.Interface) ([]byte, error)); ok {
		return rf(ctx, name, namespace, key, client)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, kubernetes.Interface) []byte); ok {
		r0 = rf(ctx, name, namespace, key, client)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, kubernetes.Interface) error); ok {
		r1 = rf(ctx, name, namespace, key, client)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KubeClientMock_GetSecretValue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSecretValue'
type KubeClientMock_GetSecretValue_Call struct {
	*mock.Call
}

// GetSecretValue is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - namespace string
//   - key string
//   - client kubernetes.Interface
func (_e *KubeClientMock_Expecter) GetSecretValue(ctx interface{}, name interface{}, namespace interface{}, key interface{}, client interface{}) *KubeClientMock_GetSecretValue_Call {
	return &KubeClientMock_GetSecretValue_Call{Call: _e.mock.On("GetSecretValue", ctx, name, namespace, key, client)}
}

func (_c *KubeClientMock_GetSecretValue_Call) Run(run func(ctx context.Context, name string, namespace string, key string, client kubernetes.Interface)) *KubeClientMock_GetSecretValue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(kubernetes.Interface))
	})
	return _c
}

func (_c *KubeClientMock_GetSecretValue_Call) Return(_a0 []byte, _a1 error) *KubeClientMock_GetSecretValue_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KubeClientMock_GetSecretValue_Call) RunAndReturn(run func(context.Context, string, string, string, kubernetes.Interface) ([]byte, error)) *KubeClientMock_GetSecretValue_Call {
	_c.Call.Return(run)
	return _c
}

// GetSimpleHealthStatus provides a mock function with given fields: ctx, namespace, labels, expectedReplicas, client
func (_m *KubeClientMock) GetSimpleHealthStatus(ctx context.Context, namespace string, labels map[string]string, expectedReplicas *int, client kubernetes.Interface) (*k8s.SimpleHealthStatus, error) {
	ret := _m.Called(ctx, namespace, labels, expectedReplicas, client)

	if len(ret) == 0 {
		panic("no return value specified for GetSimpleHealthStatus")
	}

	var r0 *k8s.SimpleHealthStatus
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]string, *int, kubernetes.Interface) (*k8s.SimpleHealthStatus, error)); ok {
		return rf(ctx, namespace, labels, expectedReplicas, client)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]string, *int, kubernetes.Interface) *k8s.SimpleHealthStatus); ok {
		r0 = rf(ctx, namespace, labels, expectedReplicas, client)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*k8s.SimpleHealthStatus)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, map[string]string, *int, kubernetes.Interface) error); ok {
		r1 = rf(ctx, namespace, labels, expectedReplicas, client)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KubeClientMock_GetSimpleHealthStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSimpleHealthStatus'
type KubeClientMock_GetSimpleHealthStatus_Call struct {
	*mock.Call
}

// GetSimpleHealthStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - namespace string
//   - labels map[string]string
//   - expectedReplicas *int
//   - client kubernetes.Interface
func (_e *KubeClientMock_Expecter) GetSimpleHealthStatus(ctx interface{}, namespace interface{}, labels interface{}, expectedReplicas interface{}, client interface{}) *KubeClientMock_GetSimpleHealthStatus_Call {
	return &KubeClientMock_GetSimpleHealthStatus_Call{Call: _e.mock.On("GetSimpleHealthStatus", ctx, namespace, labels, expectedReplicas, client)}
}

func (_c *KubeClientMock_GetSimpleHealthStatus_Call) Run(run func(ctx context.Context, namespace string, labels map[string]string, expectedReplicas *int, client kubernetes.Interface)) *KubeClientMock_GetSimpleHealthStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(map[string]string), args[3].(*int), args[4].(kubernetes.Interface))
	})
	return _c
}

func (_c *KubeClientMock_GetSimpleHealthStatus_Call) Return(_a0 *k8s.SimpleHealthStatus, _a1 error) *KubeClientMock_GetSimpleHealthStatus_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KubeClientMock_GetSimpleHealthStatus_Call) RunAndReturn(run func(context.Context, string, map[string]string, *int, kubernetes.Interface) (*k8s.SimpleHealthStatus, error)) *KubeClientMock_GetSimpleHealthStatus_Call {
	_c.Call.Return(run)
	return _c
}

// GetUnusedNodePort provides a mock function with given fields: ctx
func (_m *KubeClientMock) GetUnusedNodePort(ctx context.Context) (int32, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetUnusedNodePort")
	}

	var r0 int32
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (int32, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) int32); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(int32)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KubeClientMock_GetUnusedNodePort_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUnusedNodePort'
type KubeClientMock_GetUnusedNodePort_Call struct {
	*mock.Call
}

// GetUnusedNodePort is a helper method to define mock.On call
//   - ctx context.Context
func (_e *KubeClientMock_Expecter) GetUnusedNodePort(ctx interface{}) *KubeClientMock_GetUnusedNodePort_Call {
	return &KubeClientMock_GetUnusedNodePort_Call{Call: _e.mock.On("GetUnusedNodePort", ctx)}
}

func (_c *KubeClientMock_GetUnusedNodePort_Call) Run(run func(ctx context.Context)) *KubeClientMock_GetUnusedNodePort_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *KubeClientMock_GetUnusedNodePort_Call) Return(_a0 int32, _a1 error) *KubeClientMock_GetUnusedNodePort_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KubeClientMock_GetUnusedNodePort_Call) RunAndReturn(run func(context.Context) (int32, error)) *KubeClientMock_GetUnusedNodePort_Call {
	_c.Call.Return(run)
	return _c
}

// ListPersistentVolumeClaims provides a mock function with given fields: ctx, namespace, labels, client
func (_m *KubeClientMock) ListPersistentVolumeClaims(ctx context.Context, namespace string, labels map[string]string, client kubernetes.Interface) ([]*models.PVCInfo, error) {
	ret := _m.Called(ctx, namespace, labels, client)

	if len(ret) == 0 {
		panic("no return value specified for ListPersistentVolumeClaims")
	}

	var r0 []*models.PVCInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]string, kubernetes.Interface) ([]*models.PVCInfo, error)); ok {
		return rf(ctx, namespace, labels, client)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, map[string]string, kubernetes.Interface) []*models.PVCInfo); ok {
		r0 = rf(ctx, namespace, labels, client)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.PVCInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, map[string]string, kubernetes.Interface) error); ok {
		r1 = rf(ctx, namespace, labels, client)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KubeClientMock_ListPersistentVolumeClaims_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListPersistentVolumeClaims'
type KubeClientMock_ListPersistentVolumeClaims_Call struct {
	*mock.Call
}

// ListPersistentVolumeClaims is a helper method to define mock.On call
//   - ctx context.Context
//   - namespace string
//   - labels map[string]string
//   - client kubernetes.Interface
func (_e *KubeClientMock_Expecter) ListPersistentVolumeClaims(ctx interface{}, namespace interface{}, labels interface{}, client interface{}) *KubeClientMock_ListPersistentVolumeClaims_Call {
	return &KubeClientMock_ListPersistentVolumeClaims_Call{Call: _e.mock.On("ListPersistentVolumeClaims", ctx, namespace, labels, client)}
}

func (_c *KubeClientMock_ListPersistentVolumeClaims_Call) Run(run func(ctx context.Context, namespace string, labels map[string]string, client kubernetes.Interface)) *KubeClientMock_ListPersistentVolumeClaims_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(map[string]string), args[3].(kubernetes.Interface))
	})
	return _c
}

func (_c *KubeClientMock_ListPersistentVolumeClaims_Call) Return(_a0 []*models.PVCInfo, _a1 error) *KubeClientMock_ListPersistentVolumeClaims_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KubeClientMock_ListPersistentVolumeClaims_Call) RunAndReturn(run func(context.Context, string, map[string]string, kubernetes.Interface) ([]*models.PVCInfo, error)) *KubeClientMock_ListPersistentVolumeClaims_Call {
	_c.Call.Return(run)
	return _c
}

// OverwriteSecretValues provides a mock function with given fields: ctx, name, namespace, values, client
func (_m *KubeClientMock) OverwriteSecretValues(ctx context.Context, name string, namespace string, values map[string][]byte, client kubernetes.Interface) (*v1.Secret, error) {
	ret := _m.Called(ctx, name, namespace, values, client)

	if len(ret) == 0 {
		panic("no return value specified for OverwriteSecretValues")
	}

	var r0 *v1.Secret
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, map[string][]byte, kubernetes.Interface) (*v1.Secret, error)); ok {
		return rf(ctx, name, namespace, values, client)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, map[string][]byte, kubernetes.Interface) *v1.Secret); ok {
		r0 = rf(ctx, name, namespace, values, client)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1.Secret)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, map[string][]byte, kubernetes.Interface) error); ok {
		r1 = rf(ctx, name, namespace, values, client)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KubeClientMock_OverwriteSecretValues_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OverwriteSecretValues'
type KubeClientMock_OverwriteSecretValues_Call struct {
	*mock.Call
}

// OverwriteSecretValues is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - namespace string
//   - values map[string][]byte
//   - client kubernetes.Interface
func (_e *KubeClientMock_Expecter) OverwriteSecretValues(ctx interface{}, name interface{}, namespace interface{}, values interface{}, client interface{}) *KubeClientMock_OverwriteSecretValues_Call {
	return &KubeClientMock_OverwriteSecretValues_Call{Call: _e.mock.On("OverwriteSecretValues", ctx, name, namespace, values, client)}
}

func (_c *KubeClientMock_OverwriteSecretValues_Call) Run(run func(ctx context.Context, name string, namespace string, values map[string][]byte, client kubernetes.Interface)) *KubeClientMock_OverwriteSecretValues_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(map[string][]byte), args[4].(kubernetes.Interface))
	})
	return _c
}

func (_c *KubeClientMock_OverwriteSecretValues_Call) Return(_a0 *v1.Secret, _a1 error) *KubeClientMock_OverwriteSecretValues_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KubeClientMock_OverwriteSecretValues_Call) RunAndReturn(run func(context.Context, string, string, map[string][]byte, kubernetes.Interface) (*v1.Secret, error)) *KubeClientMock_OverwriteSecretValues_Call {
	_c.Call.Return(run)
	return _c
}

// ParseRegistryCredentials provides a mock function with given fields: secret
func (_m *KubeClientMock) ParseRegistryCredentials(secret *v1.Secret) (string, string, error) {
	ret := _m.Called(secret)

	if len(ret) == 0 {
		panic("no return value specified for ParseRegistryCredentials")
	}

	var r0 string
	var r1 string
	var r2 error
	if rf, ok := ret.Get(0).(func(*v1.Secret) (string, string, error)); ok {
		return rf(secret)
	}
	if rf, ok := ret.Get(0).(func(*v1.Secret) string); ok {
		r0 = rf(secret)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(*v1.Secret) string); ok {
		r1 = rf(secret)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(*v1.Secret) error); ok {
		r2 = rf(secret)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// KubeClientMock_ParseRegistryCredentials_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ParseRegistryCredentials'
type KubeClientMock_ParseRegistryCredentials_Call struct {
	*mock.Call
}

// ParseRegistryCredentials is a helper method to define mock.On call
//   - secret *v1.Secret
func (_e *KubeClientMock_Expecter) ParseRegistryCredentials(secret interface{}) *KubeClientMock_ParseRegistryCredentials_Call {
	return &KubeClientMock_ParseRegistryCredentials_Call{Call: _e.mock.On("ParseRegistryCredentials", secret)}
}

func (_c *KubeClientMock_ParseRegistryCredentials_Call) Run(run func(secret *v1.Secret)) *KubeClientMock_ParseRegistryCredentials_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*v1.Secret))
	})
	return _c
}

func (_c *KubeClientMock_ParseRegistryCredentials_Call) Return(_a0 string, _a1 string, _a2 error) *KubeClientMock_ParseRegistryCredentials_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *KubeClientMock_ParseRegistryCredentials_Call) RunAndReturn(run func(*v1.Secret) (string, string, error)) *KubeClientMock_ParseRegistryCredentials_Call {
	_c.Call.Return(run)
	return _c
}

// RollingRestartPodsByLabel provides a mock function with given fields: ctx, namespace, labelKey, labelValue, client
func (_m *KubeClientMock) RollingRestartPodsByLabel(ctx context.Context, namespace string, labelKey string, labelValue string, client kubernetes.Interface) error {
	ret := _m.Called(ctx, namespace, labelKey, labelValue, client)

	if len(ret) == 0 {
		panic("no return value specified for RollingRestartPodsByLabel")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, kubernetes.Interface) error); ok {
		r0 = rf(ctx, namespace, labelKey, labelValue, client)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// KubeClientMock_RollingRestartPodsByLabel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RollingRestartPodsByLabel'
type KubeClientMock_RollingRestartPodsByLabel_Call struct {
	*mock.Call
}

// RollingRestartPodsByLabel is a helper method to define mock.On call
//   - ctx context.Context
//   - namespace string
//   - labelKey string
//   - labelValue string
//   - client kubernetes.Interface
func (_e *KubeClientMock_Expecter) RollingRestartPodsByLabel(ctx interface{}, namespace interface{}, labelKey interface{}, labelValue interface{}, client interface{}) *KubeClientMock_RollingRestartPodsByLabel_Call {
	return &KubeClientMock_RollingRestartPodsByLabel_Call{Call: _e.mock.On("RollingRestartPodsByLabel", ctx, namespace, labelKey, labelValue, client)}
}

func (_c *KubeClientMock_RollingRestartPodsByLabel_Call) Run(run func(ctx context.Context, namespace string, labelKey string, labelValue string, client kubernetes.Interface)) *KubeClientMock_RollingRestartPodsByLabel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(kubernetes.Interface))
	})
	return _c
}

func (_c *KubeClientMock_RollingRestartPodsByLabel_Call) Return(_a0 error) *KubeClientMock_RollingRestartPodsByLabel_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *KubeClientMock_RollingRestartPodsByLabel_Call) RunAndReturn(run func(context.Context, string, string, string, kubernetes.Interface) error) *KubeClientMock_RollingRestartPodsByLabel_Call {
	_c.Call.Return(run)
	return _c
}

// StreamPodLogs provides a mock function with given fields: ctx, namespace, opts, meta, client, eventChan
func (_m *KubeClientMock) StreamPodLogs(ctx context.Context, namespace string, opts loki.LokiLogStreamOptions, meta loki.LogMetadata, client kubernetes.Interface, eventChan chan<- loki.LogEvents) error {
	ret := _m.Called(ctx, namespace, opts, meta, client, eventChan)

	if len(ret) == 0 {
		panic("no return value specified for StreamPodLogs")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, loki.LokiLogStreamOptions, loki.LogMetadata, kubernetes.Interface, chan<- loki.LogEvents) error); ok {
		r0 = rf(ctx, namespace, opts, meta, client, eventChan)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// KubeClientMock_StreamPodLogs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StreamPodLogs'
type KubeClientMock_StreamPodLogs_Call struct {
	*mock.Call
}

// StreamPodLogs is a helper method to define mock.On call
//   - ctx context.Context
//   - namespace string
//   - opts loki.LokiLogStreamOptions
//   - meta loki.LogMetadata
//   - client kubernetes.Interface
//   - eventChan chan<- loki.LogEvents
func (_e *KubeClientMock_Expecter) StreamPodLogs(ctx interface{}, namespace interface{}, opts interface{}, meta interface{}, client interface{}, eventChan interface{}) *KubeClientMock_StreamPodLogs_Call {
	return &KubeClientMock_StreamPodLogs_Call{Call: _e.mock.On("StreamPodLogs", ctx, namespace, opts, meta, client, eventChan)}
}

func (_c *KubeClientMock_StreamPodLogs_Call) Run(run func(ctx context.Context, namespace string, opts loki.LokiLogStreamOptions, meta loki.LogMetadata, client kubernetes.Interface, eventChan chan<- loki.LogEvents)) *KubeClientMock_StreamPodLogs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(loki.LokiLogStreamOptions), args[3].(loki.LogMetadata), args[4].(kubernetes.Interface), args[5].(chan<- loki.LogEvents))
	})
	return _c
}

func (_c *KubeClientMock_StreamPodLogs_Call) Return(_a0 error) *KubeClientMock_StreamPodLogs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *KubeClientMock_StreamPodLogs_Call) RunAndReturn(run func(context.Context, string, loki.LokiLogStreamOptions, loki.LogMetadata, kubernetes.Interface, chan<- loki.LogEvents) error) *KubeClientMock_StreamPodLogs_Call {
	_c.Call.Return(run)
	return _c
}

// SyncDatabaseSecretForService provides a mock function with given fields: ctx, service
func (_m *KubeClientMock) SyncDatabaseSecretForService(ctx context.Context, service *ent.Service) error {
	ret := _m.Called(ctx, service)

	if len(ret) == 0 {
		panic("no return value specified for SyncDatabaseSecretForService")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *ent.Service) error); ok {
		r0 = rf(ctx, service)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// KubeClientMock_SyncDatabaseSecretForService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SyncDatabaseSecretForService'
type KubeClientMock_SyncDatabaseSecretForService_Call struct {
	*mock.Call
}

// SyncDatabaseSecretForService is a helper method to define mock.On call
//   - ctx context.Context
//   - service *ent.Service
func (_e *KubeClientMock_Expecter) SyncDatabaseSecretForService(ctx interface{}, service interface{}) *KubeClientMock_SyncDatabaseSecretForService_Call {
	return &KubeClientMock_SyncDatabaseSecretForService_Call{Call: _e.mock.On("SyncDatabaseSecretForService", ctx, service)}
}

func (_c *KubeClientMock_SyncDatabaseSecretForService_Call) Run(run func(ctx context.Context, service *ent.Service)) *KubeClientMock_SyncDatabaseSecretForService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*ent.Service))
	})
	return _c
}

func (_c *KubeClientMock_SyncDatabaseSecretForService_Call) Return(_a0 error) *KubeClientMock_SyncDatabaseSecretForService_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *KubeClientMock_SyncDatabaseSecretForService_Call) RunAndReturn(run func(context.Context, *ent.Service) error) *KubeClientMock_SyncDatabaseSecretForService_Call {
	_c.Call.Return(run)
	return _c
}

// SyncDatabaseSecretForServiceID provides a mock function with given fields: ctx, serviceID
func (_m *KubeClientMock) SyncDatabaseSecretForServiceID(ctx context.Context, serviceID uuid.UUID) error {
	ret := _m.Called(ctx, serviceID)

	if len(ret) == 0 {
		panic("no return value specified for SyncDatabaseSecretForServiceID")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = rf(ctx, serviceID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// KubeClientMock_SyncDatabaseSecretForServiceID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SyncDatabaseSecretForServiceID'
type KubeClientMock_SyncDatabaseSecretForServiceID_Call struct {
	*mock.Call
}

// SyncDatabaseSecretForServiceID is a helper method to define mock.On call
//   - ctx context.Context
//   - serviceID uuid.UUID
func (_e *KubeClientMock_Expecter) SyncDatabaseSecretForServiceID(ctx interface{}, serviceID interface{}) *KubeClientMock_SyncDatabaseSecretForServiceID_Call {
	return &KubeClientMock_SyncDatabaseSecretForServiceID_Call{Call: _e.mock.On("SyncDatabaseSecretForServiceID", ctx, serviceID)}
}

func (_c *KubeClientMock_SyncDatabaseSecretForServiceID_Call) Run(run func(ctx context.Context, serviceID uuid.UUID)) *KubeClientMock_SyncDatabaseSecretForServiceID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *KubeClientMock_SyncDatabaseSecretForServiceID_Call) Return(_a0 error) *KubeClientMock_SyncDatabaseSecretForServiceID_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *KubeClientMock_SyncDatabaseSecretForServiceID_Call) RunAndReturn(run func(context.Context, uuid.UUID) error) *KubeClientMock_SyncDatabaseSecretForServiceID_Call {
	_c.Call.Return(run)
	return _c
}

// SyncDatabaseSecrets provides a mock function with given fields: ctx
func (_m *KubeClientMock) SyncDatabaseSecrets(ctx context.Context) error {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for SyncDatabaseSecrets")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// KubeClientMock_SyncDatabaseSecrets_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SyncDatabaseSecrets'
type KubeClientMock_SyncDatabaseSecrets_Call struct {
	*mock.Call
}

// SyncDatabaseSecrets is a helper method to define mock.On call
//   - ctx context.Context
func (_e *KubeClientMock_Expecter) SyncDatabaseSecrets(ctx interface{}) *KubeClientMock_SyncDatabaseSecrets_Call {
	return &KubeClientMock_SyncDatabaseSecrets_Call{Call: _e.mock.On("SyncDatabaseSecrets", ctx)}
}

func (_c *KubeClientMock_SyncDatabaseSecrets_Call) Run(run func(ctx context.Context)) *KubeClientMock_SyncDatabaseSecrets_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *KubeClientMock_SyncDatabaseSecrets_Call) Return(_a0 error) *KubeClientMock_SyncDatabaseSecrets_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *KubeClientMock_SyncDatabaseSecrets_Call) RunAndReturn(run func(context.Context) error) *KubeClientMock_SyncDatabaseSecrets_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateDeploymentImages provides a mock function with given fields: ctx, newVersion
func (_m *KubeClientMock) UpdateDeploymentImages(ctx context.Context, newVersion string) error {
	ret := _m.Called(ctx, newVersion)

	if len(ret) == 0 {
		panic("no return value specified for UpdateDeploymentImages")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, newVersion)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// KubeClientMock_UpdateDeploymentImages_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateDeploymentImages'
type KubeClientMock_UpdateDeploymentImages_Call struct {
	*mock.Call
}

// UpdateDeploymentImages is a helper method to define mock.On call
//   - ctx context.Context
//   - newVersion string
func (_e *KubeClientMock_Expecter) UpdateDeploymentImages(ctx interface{}, newVersion interface{}) *KubeClientMock_UpdateDeploymentImages_Call {
	return &KubeClientMock_UpdateDeploymentImages_Call{Call: _e.mock.On("UpdateDeploymentImages", ctx, newVersion)}
}

func (_c *KubeClientMock_UpdateDeploymentImages_Call) Run(run func(ctx context.Context, newVersion string)) *KubeClientMock_UpdateDeploymentImages_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *KubeClientMock_UpdateDeploymentImages_Call) Return(_a0 error) *KubeClientMock_UpdateDeploymentImages_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *KubeClientMock_UpdateDeploymentImages_Call) RunAndReturn(run func(context.Context, string) error) *KubeClientMock_UpdateDeploymentImages_Call {
	_c.Call.Return(run)
	return _c
}

// UpdatePersistentVolumeClaim provides a mock function with given fields: ctx, namespace, pvcName, newSize, client
func (_m *KubeClientMock) UpdatePersistentVolumeClaim(ctx context.Context, namespace string, pvcName string, newSize *string, client kubernetes.Interface) (*models.PVCInfo, error) {
	ret := _m.Called(ctx, namespace, pvcName, newSize, client)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePersistentVolumeClaim")
	}

	var r0 *models.PVCInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *string, kubernetes.Interface) (*models.PVCInfo, error)); ok {
		return rf(ctx, namespace, pvcName, newSize, client)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *string, kubernetes.Interface) *models.PVCInfo); ok {
		r0 = rf(ctx, namespace, pvcName, newSize, client)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.PVCInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, *string, kubernetes.Interface) error); ok {
		r1 = rf(ctx, namespace, pvcName, newSize, client)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KubeClientMock_UpdatePersistentVolumeClaim_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdatePersistentVolumeClaim'
type KubeClientMock_UpdatePersistentVolumeClaim_Call struct {
	*mock.Call
}

// UpdatePersistentVolumeClaim is a helper method to define mock.On call
//   - ctx context.Context
//   - namespace string
//   - pvcName string
//   - newSize *string
//   - client kubernetes.Interface
func (_e *KubeClientMock_Expecter) UpdatePersistentVolumeClaim(ctx interface{}, namespace interface{}, pvcName interface{}, newSize interface{}, client interface{}) *KubeClientMock_UpdatePersistentVolumeClaim_Call {
	return &KubeClientMock_UpdatePersistentVolumeClaim_Call{Call: _e.mock.On("UpdatePersistentVolumeClaim", ctx, namespace, pvcName, newSize, client)}
}

func (_c *KubeClientMock_UpdatePersistentVolumeClaim_Call) Run(run func(ctx context.Context, namespace string, pvcName string, newSize *string, client kubernetes.Interface)) *KubeClientMock_UpdatePersistentVolumeClaim_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(*string), args[4].(kubernetes.Interface))
	})
	return _c
}

func (_c *KubeClientMock_UpdatePersistentVolumeClaim_Call) Return(_a0 *models.PVCInfo, _a1 error) *KubeClientMock_UpdatePersistentVolumeClaim_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KubeClientMock_UpdatePersistentVolumeClaim_Call) RunAndReturn(run func(context.Context, string, string, *string, kubernetes.Interface) (*models.PVCInfo, error)) *KubeClientMock_UpdatePersistentVolumeClaim_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateSecret provides a mock function with given fields: ctx, name, namespace, data, client
func (_m *KubeClientMock) UpdateSecret(ctx context.Context, name string, namespace string, data map[string][]byte, client kubernetes.Interface) (*v1.Secret, error) {
	ret := _m.Called(ctx, name, namespace, data, client)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSecret")
	}

	var r0 *v1.Secret
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, map[string][]byte, kubernetes.Interface) (*v1.Secret, error)); ok {
		return rf(ctx, name, namespace, data, client)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, map[string][]byte, kubernetes.Interface) *v1.Secret); ok {
		r0 = rf(ctx, name, namespace, data, client)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1.Secret)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, map[string][]byte, kubernetes.Interface) error); ok {
		r1 = rf(ctx, name, namespace, data, client)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KubeClientMock_UpdateSecret_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateSecret'
type KubeClientMock_UpdateSecret_Call struct {
	*mock.Call
}

// UpdateSecret is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - namespace string
//   - data map[string][]byte
//   - client kubernetes.Interface
func (_e *KubeClientMock_Expecter) UpdateSecret(ctx interface{}, name interface{}, namespace interface{}, data interface{}, client interface{}) *KubeClientMock_UpdateSecret_Call {
	return &KubeClientMock_UpdateSecret_Call{Call: _e.mock.On("UpdateSecret", ctx, name, namespace, data, client)}
}

func (_c *KubeClientMock_UpdateSecret_Call) Run(run func(ctx context.Context, name string, namespace string, data map[string][]byte, client kubernetes.Interface)) *KubeClientMock_UpdateSecret_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(map[string][]byte), args[4].(kubernetes.Interface))
	})
	return _c
}

func (_c *KubeClientMock_UpdateSecret_Call) Return(_a0 *v1.Secret, _a1 error) *KubeClientMock_UpdateSecret_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KubeClientMock_UpdateSecret_Call) RunAndReturn(run func(context.Context, string, string, map[string][]byte, kubernetes.Interface) (*v1.Secret, error)) *KubeClientMock_UpdateSecret_Call {
	_c.Call.Return(run)
	return _c
}

// UpsertSecretValues provides a mock function with given fields: ctx, name, namespace, values, client
func (_m *KubeClientMock) UpsertSecretValues(ctx context.Context, name string, namespace string, values map[string][]byte, client kubernetes.Interface) (*v1.Secret, error) {
	ret := _m.Called(ctx, name, namespace, values, client)

	if len(ret) == 0 {
		panic("no return value specified for UpsertSecretValues")
	}

	var r0 *v1.Secret
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, map[string][]byte, kubernetes.Interface) (*v1.Secret, error)); ok {
		return rf(ctx, name, namespace, values, client)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, map[string][]byte, kubernetes.Interface) *v1.Secret); ok {
		r0 = rf(ctx, name, namespace, values, client)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1.Secret)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, map[string][]byte, kubernetes.Interface) error); ok {
		r1 = rf(ctx, name, namespace, values, client)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KubeClientMock_UpsertSecretValues_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpsertSecretValues'
type KubeClientMock_UpsertSecretValues_Call struct {
	*mock.Call
}

// UpsertSecretValues is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
//   - namespace string
//   - values map[string][]byte
//   - client kubernetes.Interface
func (_e *KubeClientMock_Expecter) UpsertSecretValues(ctx interface{}, name interface{}, namespace interface{}, values interface{}, client interface{}) *KubeClientMock_UpsertSecretValues_Call {
	return &KubeClientMock_UpsertSecretValues_Call{Call: _e.mock.On("UpsertSecretValues", ctx, name, namespace, values, client)}
}

func (_c *KubeClientMock_UpsertSecretValues_Call) Run(run func(ctx context.Context, name string, namespace string, values map[string][]byte, client kubernetes.Interface)) *KubeClientMock_UpsertSecretValues_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(map[string][]byte), args[4].(kubernetes.Interface))
	})
	return _c
}

func (_c *KubeClientMock_UpsertSecretValues_Call) Return(_a0 *v1.Secret, _a1 error) *KubeClientMock_UpsertSecretValues_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *KubeClientMock_UpsertSecretValues_Call) RunAndReturn(run func(context.Context, string, string, map[string][]byte, kubernetes.Interface) (*v1.Secret, error)) *KubeClientMock_UpsertSecretValues_Call {
	_c.Call.Return(run)
	return _c
}

// NewKubeClientMock creates a new instance of KubeClientMock. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewKubeClientMock(t interface {
	mock.TestingT
	Cleanup(func())
}) *KubeClientMock {
	mock := &KubeClientMock{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
