// Code generated by ifacemaker; DO NOT EDIT.

package k8s

import (
	"context"

	"github.com/google/uuid"
	"github.com/unbindapp/unbind-api/ent"
	"github.com/unbindapp/unbind-api/internal/infrastructure/loki"
	"github.com/unbindapp/unbind-api/internal/models"
	unbindv1 "github.com/unbindapp/unbind-operator/api/v1"
	corev1 "k8s.io/api/core/v1"
	networkingv1 "k8s.io/api/networking/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/client-go/kubernetes"
)

// KubeClientInterface ...
type KubeClientInterface interface {
	// SyncDatabaseSecrets syncs all database secrets with the operator logic
	SyncDatabaseSecrets(ctx context.Context) error
	// SyncDatabaseSecretForServiceID syncs the database secret for a specific service ID
	SyncDatabaseSecretForServiceID(ctx context.Context, serviceID uuid.UUID) error
	// SyncDatabaseSecretForService syncs the database secret for a specific service
	SyncDatabaseSecretForService(ctx context.Context, service *ent.Service) error
	// UpdateDeploymentImages updates container images in deployments based on the new version
	UpdateDeploymentImages(ctx context.Context, newVersion string) error
	// CheckDeploymentsReady checks if all deployments with unbind images have at least one pod running with the specified version
	CheckDeploymentsReady(ctx context.Context, version string) (bool, error)
	// DiscoverEndpointsByLabels returns both internal (services) and external (ingresses) endpoints
	// matching the provided labels in a namespace
	DiscoverEndpointsByLabels(ctx context.Context, namespace string, labels map[string]string, checkDNS bool, client kubernetes.Interface) (*models.EndpointDiscovery, error)
	// CreateVerificationIngress creates an ingress with a configuration snippet to help verify
	// that a domain is pointing to the Kubernetes cluster
	CreateVerificationIngress(ctx context.Context, domain string, client kubernetes.Interface) (*networkingv1.Ingress, string, error)
	// DeleteVerificationIngress deletes the verification ingress for a domain
	DeleteVerificationIngress(ctx context.Context, ingressName string, client kubernetes.Interface) error
	// DeleteOldVerificationIngresses deletes verification ingresses created more than 10 minutes ago
	DeleteOldVerificationIngresses(ctx context.Context, client kubernetes.Interface) error
	CreateDeployment(ctx context.Context, deploymentID string, env map[string]string) (jobName string, err error)
	// For canceling jobs.
	CancelJobsByServiceID(ctx context.Context, serviceID string) error
	CountActiveDeploymentJobs(ctx context.Context) (int, error)
	GetJobStatus(ctx context.Context, jobName string) (JobStatus, error)
	// This function is used to manage unbind-system resources
	GetInternalClient() kubernetes.Interface
	CreateClientWithToken(token string) (kubernetes.Interface, error)
	// ApplyYAML applies a YAML document to the cluster
	ApplyYAML(ctx context.Context, yaml []byte) error
	// GetLoadBalancerIPs returns the external IP addresses for load balancer services
	// If labelSelector is provided, it will filter services based on the selector (e.g. "app.kubernetes.io/name=ingress-nginx")
	GetLoadBalancerIPs(ctx context.Context, labelSelector string) ([]LoadBalancerAddresses, error)
	// GetIngressNginxIP is a convenience function to get the IP of the ingress-nginx controller
	GetIngressNginxIP(ctx context.Context) (*LoadBalancerAddresses, error)
	// GetUnusedNodePort returns an unused NodePort, determined by letting kubernetes allocate one then deleting the temp service
	GetUnusedNodePort(ctx context.Context) (int32, error)
	// StreamPodLogs streams logs from a pod to the provided writer with filtering
	StreamPodLogs(ctx context.Context, namespace string, opts loki.LokiLogStreamOptions, meta loki.LogMetadata, client kubernetes.Interface, eventChan chan<- loki.LogEvents) error
	// CreatePersistentVolumeClaim creates a new PersistentVolumeClaim in the specified namespace.
	CreatePersistentVolumeClaim(ctx context.Context, namespace string, pvcName string, displayName string, labels map[string]string, storageRequest string, accessModes []corev1.PersistentVolumeAccessMode, storageClassName *string, client kubernetes.Interface) (*models.PVCInfo, error)
	// UpdatePersistentVolumeClaim updates an existing PersistentVolumeClaim with new parameters (size, name)
	UpdatePersistentVolumeClaim(ctx context.Context, namespace string, pvcName string, newSize *string, client kubernetes.Interface) (*models.PVCInfo, error)
	// GetPersistentVolumeClaim retrieves a specific PersistentVolumeClaim by its name and namespace.
	GetPersistentVolumeClaim(ctx context.Context, namespace string, pvcName string, client kubernetes.Interface) (*models.PVCInfo, error)
	// ListPersistentVolumeClaims lists all PersistentVolumeClaims in a given namespace, optionally filtered by a label selector,
	ListPersistentVolumeClaims(ctx context.Context, namespace string, labels map[string]string, client kubernetes.Interface) ([]*models.PVCInfo, error)
	// DeletePersistentVolumeClaim deletes a specific PersistentVolumeClaim by its name and namespace.
	DeletePersistentVolumeClaim(ctx context.Context, namespace string, pvcName string, client kubernetes.Interface) error
	// GetPodsUsingPVC finds all pods in a given namespace that are mounting the specified PVC.
	GetPodsUsingPVC(ctx context.Context, namespace string, pvcName string, client kubernetes.Interface) ([]corev1.Pod, error)
	// GetPodContainerStatusByLabels efficiently fetches pod status with inferred events from container state
	GetPodContainerStatusByLabels(ctx context.Context, namespace string, labels map[string]string, client kubernetes.Interface) ([]PodContainerStatus, error)
	// GetPodContainerStatusByLabelsWithOptions efficiently fetches pod status with configurable options
	// Container state events are always inferred (lightweight and reliable)
	GetPodContainerStatusByLabelsWithOptions(ctx context.Context, namespace string, labels map[string]string, client kubernetes.Interface, options PodStatusOptions) ([]PodContainerStatus, error)
	GetExpectedInstances(ctx context.Context, namespace string, podName string, client kubernetes.Interface) (int, error)
	GetSimpleHealthStatus(ctx context.Context, namespace string, labels map[string]string, expectedReplicas *int, client kubernetes.Interface) (*SimpleHealthStatus, error)
	// GetPodsByLabels returns pods matching the provided labels in a namespace
	GetPodsByLabels(ctx context.Context, namespace string, labels map[string]string, client kubernetes.Interface) (*corev1.PodList, error)
	// RollingRestartPodsByLabel performs a rolling restart of all pods with a specific label
	// regardless of whether they're part of Deployments, StatefulSets, or standalone pods.
	RollingRestartPodsByLabel(ctx context.Context, namespace string, labelKey string, labelValue string, client kubernetes.Interface) error
	// DeleteStatefulSetsWithOrphanCascade deletes StatefulSets matching the label selector with orphan cascade
	DeleteStatefulSetsWithOrphanCascade(ctx context.Context, namespace string, labels map[string]string, client kubernetes.Interface) error
	// CreateMultiRegistryCredentials creates or updates a kubernetes.io/dockerconfigjson secret for multiple container registries
	CreateMultiRegistryCredentials(ctx context.Context, name, namespace string, credentials []RegistryCredential, client kubernetes.Interface) (*corev1.Secret, error)
	// After you've retrieved the credentials Secret
	ParseRegistryCredentials(secret *corev1.Secret) (string, string, error)
	// GetOrCreateSecret retrieves an existing secret or creates a new one if it doesn't exist
	// Returns the secret and a boolean indicating if it was created (true) or retrieved (false)
	GetOrCreateSecret(ctx context.Context, name, namespace string, client kubernetes.Interface) (*corev1.Secret, bool, error)
	// GetSecret retrieves a secret by name in the given namespace
	GetSecret(ctx context.Context, name, namespace string, client kubernetes.Interface) (*corev1.Secret, error)
	// UpdateSecret updates an existing secret with new data
	UpdateSecret(ctx context.Context, name, namespace string, data map[string][]byte, client kubernetes.Interface) (*corev1.Secret, error)
	// GetSecretValue retrieves a specific key from a secret
	GetSecretValue(ctx context.Context, name, namespace, key string, client kubernetes.Interface) ([]byte, error)
	// GetSecretMap retrieves all key-value pairs from a secret as a map
	GetSecretMap(ctx context.Context, name, namespace string, client kubernetes.Interface) (map[string][]byte, error)
	// DeleteSecret deletes a secret by name in the given namespace
	DeleteSecret(ctx context.Context, name, namespace string, client kubernetes.Interface) error
	// UpsertSecretValues adds or updates specific keys in a secret without affecting other keys
	UpsertSecretValues(ctx context.Context, name, namespace string, values map[string][]byte, client kubernetes.Interface) (*corev1.Secret, error)
	// OverwriteSecretValues overwrites all values in a secret with new values
	OverwriteSecretValues(ctx context.Context, name, namespace string, values map[string][]byte, client kubernetes.Interface) (*corev1.Secret, error)
	// GetAllSecrets retrieves all secrets for the team hierarchy concurrently and returns them with just their keys
	GetAllSecrets(ctx context.Context, teamID uuid.UUID, teamSecret string, projectID uuid.UUID, projectSecret string, environmentID uuid.UUID, environmentSecret string, serviceSecrets map[uuid.UUID]string, client kubernetes.Interface, namespace string) ([]models.SecretData, error)
	// CopySecret copies a secret from one namespace to another
	CopySecret(ctx context.Context, secretName string, sourceNamespace string, targetNamespace string, client kubernetes.Interface) (*corev1.Secret, error)
	// AvailableStorageBytes inspects the default StorageClass and returns
	// capacity / sizing metadata
	//
	// • Longhorn  – sums .status.diskStatus[*].storageAvailable live
	// • Hetzner   – 10 TiB max, 10 GiB min, 1 GiB step
	// • AWS EBS   – 64 TiB max, 1 GiB  min, 1 GiB step
	// • Azure Disk – 64 TiB max, 1 GiB  min, 1 GiB step
	// • GCP PD    – 64 TiB max, 1 GiB  min, 1 GiB step
	// • DigitalOcean Volumes – 16 TiB max, 1 GiB min, 1 GiB step
	// • Vultr Block Storage  – 10 TiB max, 10 GiB min, 1 GiB step
	// • Linode Block Storage – 16 TiB max, 10 GiB min, 1 GiB step
	// • OpenStack Cinder     – 12 TiB max, 10 GiB min, 1 GiB step
	//
	// Anything else falls through with UnableToDetectAllocatable=true.
	AvailableStorageBytes(ctx context.Context) (*StorageMetadata, error)
	// Gets specified namespaces
	GetNamespaces(ctx context.Context, namespaceNames []string, bearerToken string) ([]*corev1.Namespace, error)
	// CreateNamespace creates a new namespace in the Kubernetes cluster
	CreateNamespace(ctx context.Context, namespaceName string, client kubernetes.Interface) (*corev1.Namespace, error)
	// Delete a custom unbind service CRD
	DeleteUnbindService(ctx context.Context, namespace, name string) error
	// DeployImage creates (or replaces) the service resource in the target namespace
	// for deployment after a successful build job.
	DeployUnbindService(ctx context.Context, service *unbindv1.Service) (*unstructured.Unstructured, *unbindv1.Service, error)
}
